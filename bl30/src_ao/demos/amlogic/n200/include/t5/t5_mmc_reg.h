// ----------------------------------------------------------------------
// This file is automatically generated from the script:
//
// ./create_headers_for_mmc_register_map_h.pl
//
// and was applied to the file
//
// Project name: t5
//
// Create time: Fri Jun 12 11:28:10 CST 2020 by leilei.ge
//
// ./mmc_reg.vh
//
// DO NOT EDIT!!!!!
// ----------------------------------------------------------------------
//
#ifdef MMC_REG_DEFINE
#else
#define MMC_REG_DEFINE

#if 0
#define MMC_Wr(addr, data) *(volatile uint32_t *)(addr)=(data)
#define MMC_Rd(addr) *(volatile uint32_t *)(addr)
#define writel(v,c)  *(volatile uint32_t *)(c ) = v
#define readl(c)  *(volatile uint32_t *)(c )
#endif

//
// Reading file:  ./mmc_reg.vh
//
//
// Reading file:  ../mmc_lp4/dmc_clk_freq/rtl/dmc_clk_freq.vh
//
// APB1_BASE_ADDR       	 32'hff638c00
// -----------------------------------------------
// REG_BASE:  DMC_FREQ_REG_BASE = 0xff638c00
// -----------------------------------------------

#define AM_DDR_PLL_CNTL0                           ((0x0000  << 2) + 0xff638c00)
  //bit 29    : dpll_reset.
  //bit 28    : dpll_en.
  //bit 27:26 : dpll_clk_en
  //bit 25    : dpll_inv_sel
  //bit 21:19 : od1  OD1[0] : 0 /2,  1: /4.   OD1[2:1].  2'b00: /1, 2'b01: /2. 2'b10 /4. 2'b11: /8.
  //bit 18:16 : od
  //bit 14:10 : dpll_ref_div_n
  //bit 8:0   : dpll_int_num

#define AM_DDR_PLL_CNTL1                           ((0x0001  << 2) + 0xff638c00)
  //bit 18:0    : ddr_dpll_frac
#define AM_DDR_PLL_CNTL2                           ((0x0002  << 2) + 0xff638c00)
  //bit 22:20  : fref_sel
  //bit 17:16  : os_ssc
  //bit 15:12  : ssc_str_m
  //bit 8      : ssc_en
  //bit 7:4    : ssc_dep_sel
  //bit 1:0    : dpll ss_mode.
#define AM_DDR_PLL_CNTL3                           ((0x0003  << 2) + 0xff638c00)
  //bit 31     : afc bypass
  //bit 30     : afc clk sel
  //bit 29     : code new
  //bit 28     : dco_m_en
  //bit 27     : dco_sdm_en
  //bit 26     : div2
  //bit 25     : div mode
  //bit 24     : fast_lock mode
  //bit 23     : fb_pre_div
  //bit 22     : filter_mode
  //bit 21     : fix_en
  //bit 20     : freq_shift_en
  //bit 19     : load
  //bit 18     : load_en
  //bit 17     : lock_f
  //bit 16     : pulse_width_en
  //bit 15     : sdmnc_en
  //bit 14     : sdmnc_mode
  //bit 13     : sdmnc_range
  //bit 12     : tdc_en
  //bit 11     : tdc_mode_sel
  //bit 10     :  wait_en

#define AM_DDR_PLL_CNTL4                           ((0x0004  << 2) + 0xff638c00)
  //bit 1:0    : pfd_gain
  //bit 7:4    : filter_pvt1
  //bit 11:8   : filter pvt2
  //bit 13:12  : acq_gain
  //bit 18:16  : lambda0
  //bit 22:20  : lambda1
  //bit 26:24  : rou
  //bit 30:28  : alpha
#define AM_DDR_PLL_CNTL5                           ((0x0005  << 2) + 0xff638c00)
  //bit 15:0   : reve
  //bit 21:16  : lm_s
  //bit 27:24  : lm_w
  //bit 30:28  : adj_vco_ldo

#define AM_DDR_PLL_CNTL6                           ((0x0006  << 2) + 0xff638c00)
  //bit 15:0   : reve
  //bit 21:16  : lm_s
  //bit 27:24  : lm_w
  //bit 30:28  : adj_vco_ldo

#define AM_DDR_PLL_STS                             ((0x0007  << 2) + 0xff638c00)
  //bit 31     : DDR_PLL_LOCK
  //bit 30:19  : not used.
  //bit 18     : DDR_AFC_DONE
  //bit 17     : DDR_PLL_LOCK
  //bit 16:7   : DDR_DPLL_OUT_RSV
  //bit 6:0    : DDR_SDMNC_MONITOR



#define DDR_CLK_CNTL                               ((0x0008  << 2) + 0xff638c00)
  //bit 31     ddr_pll_clk enable. enable the clock from DDR_PLL to clock generateion.
  // whenever change the DDR_PLL frequency, disable the clock, after the DDR_PLL locked, then enable it again.
  //bit 30.    ddr_pll_prod_test_en.  enable the clock to clock/32 which to clock frequency measurement and production test pin.
  //bit 29.    not used.
  //bit 28.    clock generation logic soft reset. 0 = reset.
  //bit 27.    phy_4xclk phase inverter..
  //bit 25.    DDRPHY DfiClk/DMC clock selection.  1:  AM_PLL clk output /2.  0: directly output from AM_PLL .
  //bit 24.    enable AM_PLL CLK output /2 function.   1: enable.  0: disable.   if try to use this clkoutput/2 function.
  //bit 26.    pll_freq divide/2. 1:  use pll div/2 clock as the n_clk. 0: use pll clock as n_clk.  this setting is used for the synopsys DDR PHY PLL fast lock mode.
  //bit 2. enable dmc_clk.
  //bit 1. not used.
  //bit 0. enable LPDDR4-PHY clock

#define DDR_PHY_CTRL                               ((0x0009  << 2) + 0xff638c00)
  // LPDDR4 power on reset need to special combination of PwrOkIn and phy_reset_n.
  //bit 31:  DDr PHY power on status.  read only.
  //bit 4.   DDR PHY PwrOkIn pin.
  //bit 1.   DDR PHY APB soft reset_n.
  //bit 0.   phy_reset_n.



#define AM_DDR_PLL_FREQ1_OD                        ((0x000c  << 2) + 0xff638c00)
 //freqency set 1 PLL OD and OD1 setting. when change to freqency 1 will use this setting.
//frequency set 0 use original DDR_PLL_CNTL0 setting.
 //bit 8     currunt FREQ selection.  it can forced to change to select which freqency to select, or it can auto changed by FREQ change hardware.
 //bit 5:3   OD1.
 //bit 2:0.  OD.

//
// Closing file:  ../mmc_lp4/dmc_clk_freq/rtl/dmc_clk_freq.vh
//
//
// Reading file:  ../mmc_lp4/dmc/rtl/dmc_reg.vh
//
// -----------------------------------------------
// REG_BASE:  DMC_REG_BASE = 0xff638000
// -----------------------------------------------
#define DMC_REQ_CTRL                               ((0x0000  << 2) + 0xff638000)
  //bit 23.  enable dmc request of ambus chan 7. Reserved for GE2D interface. Async interface.
  //bit 22.  enable dmc request of ambus chan 6. DOS HCODEC  interface   Sync interface.
  //bit 21.  enable dmc request of ambus chan 5. DOS VDEC  interface   Sync interface.
  //bit 20.  enable dmc request of ambus chan 4. VPU write interface 1  Sync interface.
  //bit 19.  enable dmc request of ambus chan 3. VPU write interface 0  Sync interface.
  //bit 18.  enable dmc request of ambus chan 2. VPU read interface 2.   Sync interface.
  //bit 17.  enable dmc request of ambus chan 1. VPU read interface 1.   Sync interface.
  //bit 16.  enable dmc request of ambus chan 0. VPU read interface 0.  Sync interface.
  //bit 9    enable dmc request of axibus chan 9.  wave  async interface.
  //bit 8.   enable dmc request of axibus chan 8   hevc_b  async interface.
  //bit 7.   enable dmc request of axibus chan 7.  DEVICE.    Async interface.
  //bit 6.   enable dmc request of axibus chan 6.  USB   Async interface.
  //bit 5.   enable dmc request of axibus chan 5.  reserved for dmc_test.
  //bit 4.   enable dmc request of axibus chan 4.  hevc front Async interface.
  //bit 3.   enable dmc request of axibus chan 3.  HDCP/HDMI   Async interface.
  //bit 2.   enable dmc request of axibus chan 2.  pcie  async
  //bit 1.   enable dmc request of axibus chan 1.  Mali .  async interface.
  //bit 0.   enable dmc request of axibus chan 0.  CPU/A53   async interface.

//DMC CLK and RESET domain register. please check DMC_SEC_APB_CTRLx register for access details.
#define DMC_SOFT_RST                               ((0x0001  << 2) + 0xff638000)
  //bit 31~24. reserved for future.
  //bit 23:16 8 AMBUS input interface n_clk domain reset_n signal. 0 : reset.  1: normal working mode.
  //bit 15:0. 16 AXI BUS input intefaces n_clk domain reset_n signal. 0: reset. 1: normal working mode. each bit for one interface.

#define DMC_SOFT_RST1                              ((0x0002  << 2) + 0xff638000)
  //To reset the Async interface, you need to disable the interface both clock domain, then reset both n_clk and m_clk domain
  //bit 31~24 not used.
  //bit 23.16  8 am bus interfaces master clock domain reset_n signal. 0 : reset : 1 normal working mode.
  //bit 15:0.  16 AXI bus interfaces master clock domain reset_n signal. 0 : reset : 1 normal working mode.

#define DMC_SOFT_RST2                              ((0x0003  << 2) + 0xff638000)
  //bit 31~11.  reserved for future.
  //bit 10  DMC DFI cmd soft reset_n
  //bit 9   DMC DFI MISC soft reset_n
  //bit 8   DMC DFI data soft reset_n
  //bit 7   DMC DFI dcu soft reset_n
  //bit 6   DMC siu soft reset_n
  //bit 5.  DMC test soft reset_n.  0 : reset. 1 : normal working mode.
  //bit 4.  DMC low power control moudle soft reset_n.    0 : reset. 1 : normal working mode.
  //bit 3.  DMC QOS monitor module soft reset_n.   0 : reset. 1 : normal working mode.
  //bit 2.  DMC register modle soft reset_n.       0 : reset. 1 : normal working mode.
  //bit 1.  DMC canvas transfer module soft reset_n.  0 : reset. 1 : normal working mode.
  //bit 0.  DMC command buffers and command generation modules soft reset.  0 = reset. 1:

#define DMC_RST_STS1                               ((0x0004  << 2) + 0xff638000)
  //31~24.  not used.
  //23~0.   Read only.  the DMC_SOFT_RST1 signal in n_clk domain. the purpose of this register is when one of the 2 clocks is too slow or too fast,  we can read this register to make sure another clock domain reset is done.
#define DMC_CLKG_CTRL0                             ((0x0006  << 2) + 0xff638000)
  //bit 23:16. enable the 8 ambus interfaces both main and n_clk auto clock gating function. each 1 bit for one interface.
  //bit 15:0.  enable the 16 axi interfaces both main and n_clk auto clock gating function. each 1 bit for one interface.
#define DMC_CLKG_CTRL1                             ((0x0007  << 2) + 0xff638000)
  //bit 23:16. force to disable the 8 ambus interfaces both main and n_clk. each 1 bit for one interface.
  //bit 15:0.  force to disable the 16 axi interfaces both main and n_clk. each 1 bit for one interface.

#define DMC_CLKG_CTRL2                             ((0x0008  << 2) + 0xff638000)
  //bit 12  enalbe auto clock gating for awcmdfifo.
  //bit 11  enalbe auto clock gating for arcmdfifo.
  //bit 10  enable auto clock gating for dfi command generation
  //bit 9   enable auto clock gating for dram cntroller
  //bit 8   enable auto clock gating for dfi data path.
  //bit 7.  enalbe auto clock gating for write rsp generation.
  //bit 6.  enalbe auto clock gating for read rsp generation.
  //bit 5.  enalbe auto clock gating for ddr0 command filter.
  //bit 4.  enalbe auto clock gating for ddr0 write reorder buffer.
  //bit 3.  enalbe auto clock gating for ddr0 write data buffer.
  //bit 2.  enalbe auto clock gating for ddr0 read reorder buffer.
  //bit 1.  enalbe auto clock gating for read canvas.
  //bit 0.  enalbe auto clock gating for write canvas.

#define DMC_CLKG_CTRL3                             ((0x0009  << 2) + 0xff638000)
  //bit 12  force to disable the clock of awcmdfifo.
  //bit 11  force to disable the clock of arcmdfifo.
  //bit 10  force to disable the clock of dfi command generation
  //bit 9   force to disable the clock of dram cntroller
  //bit 8   force to disable the clock of dfi data path.
  //bit 7. force to disalbe the clock of write rsp generation.
  //bit 6. force to disalbe the clock of read rsp generation.
  //bit 5.  force to disalbe the clock of  command filter.
  //bit 4.  force to disalbe the clock of  write reorder buffer.
  //bit 3.  force to disalbe the clock of write data buffer.
  //bit 2.  force to disalbe the clock of read reorder buffer.
  //bit 1.  force to disalbe the clock of read canvas.
  //bit 0.  force to disalbe the clock of write canvas.


// DMC CANVAS setting domain control regsiters.
#define DC_CAV_LUT_DATAL                           ((0x0012  << 2) + 0xff638000)
  //low 32 bits of canvas data which need to be configured to canvas memory.
#define DC_CAV_LUT_DATAH                           ((0x0013  << 2) + 0xff638000)
  //high 32bits of cavnas data which need to be configured to canvas memory.
  //64bits CANVAS look up table
  //bit 60:58   Endian control.
      //3'b000:  no endian change.
      //3'b001:
  //bit 57:56.   Canvas block mode.  2 : 64x32, 1: 32x32; 0 : linear mode.
  //bit 55:      canvas Y direction wrap control. 1: wrap back in y.  0: not wrap back.
  //bit 54:      canvas X direction wrap control. 1: wrap back in X.  0: not wrap back.
  //bit 53:41.   canvas Hight.
  //bit 40:29.   canvas Width, unit: 8bytes. must in 32bytes boundary. that means last 2 bits must be 0.
  //bit 28:0.    cavnas start address.   unit. 8 bytes. must be in 32bytes boundary. that means last 2bits must be 0.

#define DC_CAV_LUT_ADDR                            ((0x0014  << 2) + 0xff638000)
  //bit 9:8.   write 9:8 2'b10. the canvas data will saved in canvas memory with addres 7:0.
  //bit 7:0.   256 canvas Look up table address.

#define DC_CAV_LUT_RDATAL                          ((0x0015  << 2) + 0xff638000)
  // CBUS low 32bytes canvas read back data from LUT.
#define DC_CAV_LUT_RDATAH                          ((0x0016  << 2) + 0xff638000)
  // Cbus high 32bytes canvas read back data from LUT.

// there are total 256 canvas table, So we added a 256bits register to record the those canvas mode.
// when we configure the canvas table and if the canvas mode is 32x32 blkmode, we'll mark this related bit.
// we will use this bit to check the VPU canvas access. if it's in 32x32 blkmode, we need break the input in 32bytes boundary.
// You can also use below register to read/write those bit.
#define DC_CAV_BLK_CTRL0                           ((0x0018  << 2) + 0xff638000)
 //canvas index 31:0 blkmode. 1 : 32x32. 0 : others.
#define DC_CAV_BLK_CTRL1                           ((0x0019  << 2) + 0xff638000)
 //canvas index 63:32 blkmode. 1 : 32x32. 0 : others.
#define DC_CAV_BLK_CTRL2                           ((0x001a  << 2) + 0xff638000)
 //canvas index 95:64 blkmode. 1 : 32x32. 0 : others.
#define DC_CAV_BLK_CTRL3                           ((0x001b  << 2) + 0xff638000)
 //canvas index 127:96 blkmode. 1 : 32x32. 0 : others.
#define DC_CAV_BLK_CTRL4                           ((0x001c  << 2) + 0xff638000)
 //canvas index 159:128 blkmode. 1 : 32x32. 0 : others.
#define DC_CAV_BLK_CTRL5                           ((0x001d  << 2) + 0xff638000)
 //canvas index 191:160 blkmode. 1 : 32x32. 0 : others.
#define DC_CAV_BLK_CTRL6                           ((0x001e  << 2) + 0xff638000)
 //canvas index 223:192 blkmode. 1 : 32x32. 0 : others.
#define DC_CAV_BLK_CTRL7                           ((0x001f  << 2) + 0xff638000)
 //canvas index 255:224 blkmode. 1 : 32x32. 0 : others.


#define DMC_MON_CTRL0                              ((0x0020  << 2) + 0xff638000)
   //bit 31.   qos_mon_en.    write 1 to trigger the enable. polling this bit 0, means finished.  or use interrupt to check finish.
   //bit 30.   qos_mon interrupt clear.  clear the qos monitor result.  read 1 = qos mon finish interrupt.
   //bit 7.    BW monitor 3 enable.
   //bit 6.    BW monitor 3 enable.
   //bit 5.    BW monitor 3 enable.
   //bit 4.    BW monitor 3 enable.
   //bit 3.    BW monitor 3 enable.
   //bit 2.    BW monitor 2 enable.
   //bit 1.    BW monitor 1 enable.
   //bit 0.    BW monitor 0 enable.
#define DMC_MON_TIMER                              ((0x0021  << 2) + 0xff638000)
 // timer for the monitor period.
#define DMC_MON_ALL_IDLE_CNT                       ((0x0022  << 2) + 0xff638000)
  // at the test period,  the whole MMC all channel IDLE time. unit, dmc clock.
#define DMC_MON_ALL_BW                             ((0x0023  << 2) + 0xff638000)
  // at the test period,  the whole MMC granted data cycles. 64bits unit.
#define DMC_MON_ALL16_BW                           ((0x0024  << 2) + 0xff638000)
  // at the test period,  the whole MMC granted data cycles which goes to 16bits ddr. unit:64bits

#define DMC_MON0_CTRL                              ((0x0030  << 2) + 0xff638000)
  //BW MONTIOR 0 address range ctrol.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON0_CTRL1                             ((0x0031  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 0 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON0_CTRL2                             ((0x0032  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 0 port select for the selected channel.
#define DMC_MON0_BW                                ((0x0033  << 2) + 0xff638000)
  // at the test period, this range granted data cycles for the seletec channel and ports.

#define DMC_MON1_CTRL                              ((0x0034  << 2) + 0xff638000)
  //BW monitor 1 address range ctrol.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON1_CTRL1                             ((0x0035  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 1 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON1_CTRL2                             ((0x0036  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 1 port select for the selected channel.
#define DMC_MON1_BW                                ((0x0037  << 2) + 0xff638000)
  // at the test period, this range granted data cycles for the seletec channel and ports.

#define DMC_MON2_CTRL                              ((0x0038  << 2) + 0xff638000)
  //BW monitor 2 address range ctrol.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON2_CTRL1                             ((0x0039  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 2 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON2_CTRL2                             ((0x003a  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 2 port select for the selected channel.
#define DMC_MON2_BW                                ((0x003b  << 2) + 0xff638000)
  // at the test period, this range granted data cycles for the seletec channel and ports.

#define DMC_MON3_CTRL                              ((0x003c  << 2) + 0xff638000)
  //BW monitor 3 address range ctrol.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON3_CTRL1                             ((0x003d  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 3 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON3_CTRL2                             ((0x003e  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 3 port select for the selected channel.
#define DMC_MON3_BW                                ((0x003f  << 2) + 0xff638000)
  // at the test period, this range granted data cycles for the seletec channel and ports.

#define DMC_MON4_CTRL                              ((0x00c0  << 2) + 0xff638000)
  //BW monitor 4 address range ctrol.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON4_CTRL1                             ((0x00c1  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 4 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON4_CTRL2                             ((0x00c2  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 4 port select for the selected channel.
#define DMC_MON4_BW                                ((0x00c3  << 2) + 0xff638000)
  // at the test period, this range granted data cycles for the seletec channel and ports.

#define DMC_MON5_CTRL                              ((0x00c4  << 2) + 0xff638000)
  //BW monitor 5 address range ctrol.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON5_CTRL1                             ((0x00c5  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 5 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON5_CTRL2                             ((0x00c6  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 5 port select for the selected channel.
#define DMC_MON5_BW                                ((0x00c7  << 2) + 0xff638000)
  // at the test period, this range granted data cycles for the seletec channel and ports.

#define DMC_MON6_CTRL                              ((0x00c8  << 2) + 0xff638000)
  //BW monitor 6 address range ctrol.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON6_CTRL1                             ((0x00c9  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 6 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON6_CTRL2                             ((0x00ca  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 6 port select for the selected channel.
#define DMC_MON6_BW                                ((0x00cb  << 2) + 0xff638000)
  // at the test period, this range granted data cycles for the seletec channel and ports.


#define DMC_MON7_CTRL                              ((0x00cc  << 2) + 0xff638000)
  //BW monitor 7 address range ctrol.  start addrss <= AXI address[31:16] <= end address
  //bit 31:16  End address[31:16]
  //bit 15:0.  start address[31:16]
#define DMC_MON7_CTRL1                             ((0x00cd  << 2) + 0xff638000)
   //bit 23:0.  BW monitor 7 channel select.   8 ambus port and 16 AXI port selection. 1 bit for one port.
  // if only 1 channel selected, you can use DMC_MONx_CTRL2 to chose any subid of this selected channel. otherwise DMC_MONx_CTRL2 should be set 0xffff
#define DMC_MON7_CTRL2                             ((0x00ce  << 2) + 0xff638000)
   //bit 15:0.  BW monitor 7 port select for the selected channel.
#define DMC_MON7_BW                                ((0x00cf  << 2) + 0xff638000)
  // at the test period, this range granted data cycles for the seletec channel and ports.






#define DMC_CMD_FILTER_CTRL1                       ((0x0040  << 2) + 0xff638000)
  //not used.
#define DMC_CMD_FILTER_CTRL2                       ((0x0041  << 2) + 0xff638000)
  //31:24. keep the bank active if there's urgent level 3 read bank hit request.
  //23:16. keep the bank active if there's urgent level 2 read bank hit request.
  //15:8.  keep the bank active if there's urgent level 1 read bank hit request.
  //7:0.   keep the bank active if there's urgent level 0 read bank hit request.

#define DMC_CMD_FILTER_CTRL3                       ((0x0042  << 2) + 0xff638000)
  //bit 31.    force wbuf empty.
  //bit 30:26  wbuf high level number
  //bit 25:21  wbuf mid  level number
  //bit 20:16  wbuf low level number
  //bit 14:10  rbuf high level number
  //bit 9:5    rbuf middle level number
  //bit 4:0    rbuf low level number

#define DMC_CMD_FILTER_CTRL4                       ((0x0043  << 2) + 0xff638000)
  //bit 29:25.  tITW.long
  //bit 24:20.  tITW. short
  //bit 19:12   tAP auto precharge the bank not used if idle that long time.
  //bit 11:6    write to read accesses if there write hit request.
  //bit 5:0     read to write accesses if there write hit request.

#define DMC_CMD_FILTER_CTRL5                       ((0x0044  << 2) + 0xff638000)
  //bit 31:24   Once ddr data bus switch to read, the maxmum read command number to give up the bus when there's write request pending for write buffer.
  //bit 23:16   Once ddr data bus switch to write, the maxmum write command number to give up the bus when there's read request pending too long.
  //bit 15:8.   Once ddr data bus switch to read, the minimum read command number to transfer back to write stage if there's still pending read request.
  //bit 7:0.    Once ddr data bus switch to write, the minimum write command number to transfer back to read stage if there's still pending write request.

#define DMC_CMD_FILTER_CTRL6                       ((0x0045  << 2) + 0xff638000)
  //bit 31:24   write urgent 3 request pending hold num.
  //bit 23:16   write urgent 2 request pending hold num.
  //bit 15:8.   write urgent 1 request pending hold num.
  //bit 7:0.    write urgent 0 request pending hold num.

#define DMC_CMD_FILTER_CTRL7                       ((0x0046  << 2) + 0xff638000)
  //bit 31:24.  aw_req_pedning singal assertion after wbuf full.
  //bit 23:16   aw_req_pending singal hold how long if wbuf not full.
  //bit 15:8    write to read waiting cycles if there write hit request.
  //bit 7:0     read to write waiting cycles if there write hit request.

#define DMC_CMD_FILTER_CTRL8                       ((0x0047  << 2) + 0xff638000)
  //bit 31:8    reserved.
  //bit 7:0     rank limit to change to another rank.


#define DMC_CMD_BUFFER_CTRL                        ((0x0048  << 2) + 0xff638000)
  //bit 31:26  total write buffer number. default 32.
  //bit 25:20  total read buffer number. default 32.
  //bit 19:8    reserved.
  //bit 7:0    aw_pending_inc_num.  incease write ugent level 1 when write command waiting to in write buffer that long.

#define DMC_CMD_BUFFER_CTRL1                       ((0x0049  << 2) + 0xff638000)
  //bit 29:24  read buffer number in non-urgent request.
  //bit 23:16  read buffer bank miss watch dog threshold.
  //bit 15:12  read buffer urgent level 3 counter inc weight.
  //bit 11:8   read buffer urgent level 2 counter inc weight.
  //bit 7:4    read buffer urgent level 1 counter inc weight.
  //bit 3:0    read buffer urgent level 0 counter inc weight.

#define DMC_2ARB_CTRL                              ((0x004c  << 2) + 0xff638000)
  //32:24. Waiting limit to use the highest urgent level in the pipelines.
  //22.    1: allow to increase 2 urgent levels if waiting time is doubled than inc_ugt_limit.
  //21:12  inc_ugt_limit.  if waiting time > inc_ugt_limit, increase the urgent level by one
  //11:6.  the final arbitration control from AXI bus(port channel 0~7).
  //5:0.   the final arbitration weight control for Ambus ( port channel 8~15).
#define DMC_VERSION                                ((0x004f  << 2) + 0xff638000)
   //read only 32'h000a0008  for sc2


#define DMC_AM0_CHAN_CTRL                          ((0x0060  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AM0_HOLD_CTRL                          ((0x0061  << 2) + 0xff638000)
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AM0_CHAN_CTRL1                         ((0x0062  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM0_CHAN_CTRL2                         ((0x0063  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when side band signal used as block other request, and side bank signal is high,  block the ambus related bits write request.
 //bit 15:0  : when side band signal used as block other request, and side bank signal is high,  block the axi bus related bits write request.

#define DMC_AM1_CHAN_CTRL                          ((0x0064  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AM1_HOLD_CTRL                          ((0x0065  << 2) + 0xff638000)
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AM1_CHAN_CTRL1                         ((0x0066  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM1_CHAN_CTRL2                         ((0x0067  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when side band signal used as block other request, and side bank signal is high,  block the ambus related bits write request.
 //bit 15:0  : when side band signal used as block other request, and side bank signal is high,  block the axi bus related bits write request.

#define DMC_AM2_CHAN_CTRL                          ((0x0068  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AM2_HOLD_CTRL                          ((0x0069  << 2) + 0xff638000)
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AM2_CHAN_CTRL1                         ((0x006a  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM2_CHAN_CTRL2                         ((0x006b  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when side band signal used as block other request, and side bank signal is high, block the ambus related bits write request.
 //bit 15:0  : when side band signal used as block other request, and side bank signal is high, block the axi bus related bits write request.

#define DMC_AM3_CHAN_CTRL                          ((0x006c  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AM3_HOLD_CTRL                          ((0x006d  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AM3_CHAN_CTRL1                         ((0x006e  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM3_CHAN_CTRL2                         ((0x006f  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when side band signal used as block other request, and side bank signal is high, block the ambus related bits write request.
 //bit 15:0  : when side band signal used as block other request, and side bank signal is high, block the axi bus related bits write request.

#define DMC_AM4_CHAN_CTRL                          ((0x0070  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AM4_HOLD_CTRL                          ((0x0071  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AM4_CHAN_CTRL1                         ((0x0072  << 2) + 0xff638000)
 //bit 31:    side band signal used as block other request.
 //bit 30 :   side band urgent  increase enable.
 //bit 29 :   side band urgent decrease urgent enable.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits read request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits read request.

#define DMC_AM4_CHAN_CTRL2                         ((0x0073  << 2) + 0xff638000)
 //bit 31:24  not used.
 //bit 23:16 : when bit 31 enabled, block the ambus related bits write request.
 //bit 15:0  : when bit 31 enabled, block the axi bus related bits write request.

#define DMC_AM5_CHAN_CTRL                          ((0x0074  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AM5_HOLD_CTRL                          ((0x0075  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.


#define DMC_AM6_CHAN_CTRL                          ((0x0078  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AM6_HOLD_CTRL                          ((0x0079  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.


#define DMC_AM7_CHAN_CTRL                          ((0x007c  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AM7_HOLD_CTRL                          ((0x007d  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.


#define DMC_AXI0_CHAN_CTRL                         ((0x0080  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi0 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      arbiter weight
#define DMC_AXI0_HOLD_CTRL                         ((0x0081  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI0_CHAN_CTRL1                        ((0x0082  << 2) + 0xff638000)
  //bit 31:28.  FIQ status
  //bit 27:24.  IRQ status.
  //bit 22      use ACTIVE input as clock gating control.
  //bit 21:20.  chan0 QOS mode.
  //bit 19:16.   AXI0 QOS high limit.
  //bit 15:12    AXI0 QOS mit limit.
  //bit 11  ARM  FIQ controlled super urgent enable.
  //bit 10  ARM  FIQ controlled urgent enable.
  //bit  9. ARM IRQ controlled super urgent enable.
  //bit  8. ARM IRQ controlled urgent enable.
  //bit  7.  IRQ/FIQ controll enable.
  //bit  6:5.  not used.
  //bit 4. enable AXI0 auto urgent enable. When there's no other request, treat the AXI0 as super urgent request. other wise, use the bit3:0 to set the urgent.
  //bit 3:2 A9 urgent if there's VIU request.
  //bit 1:0 A9 urgent if there's request other than VIU


#define DMC_AXI1_CHAN_CTRL                         ((0x0084  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI1_HOLD_CTRL                         ((0x0085  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI1_CHAN_CTRL1                        ((0x0086  << 2) + 0xff638000)
  //bit 31:28.  FIQ status
  //bit 27:24.  IRQ status.
  //bit 21:20.  Mali QOS mode.
  //bit 19:16.   mail QOS high limit.
  //bit 15:12    mail QOS mit limit.
  //bit 11  ARM  FIQ controlled super urgent enable.
  //bit 10  ARM  FIQ controlled urgent enable.
  //bit  9. ARM IRQ controlled super urgent enable.
  //bit  8. ARM IRQ controlled urgent enable.
  //bit  7.  IRQ/FIQ controll enable.
  //bit  6:0.  not used.


#define DMC_AXI2_CHAN_CTRL                         ((0x0088  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI2_HOLD_CTRL                         ((0x0089  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI3_CHAN_CTRL                         ((0x008c  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI3_HOLD_CTRL                         ((0x008d  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI4_CHAN_CTRL                         ((0x0090  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI4_HOLD_CTRL                         ((0x0091  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI5_CHAN_CTRL                         ((0x0094  << 2) + 0xff638000)
  //not used.
#define DMC_AXI5_HOLD_CTRL                         ((0x0095  << 2) + 0xff638000)
  //not used.


#define DMC_AXI6_CHAN_CTRL                         ((0x0098  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI6_HOLD_CTRL                         ((0x0099  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI7_CHAN_CTRL                         ((0x009c  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI7_HOLD_CTRL                         ((0x009d  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI8_CHAN_CTRL                         ((0x00a0  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI8_HOLD_CTRL                         ((0x00a1  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI9_CHAN_CTRL                         ((0x00a4  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI9_HOLD_CTRL                         ((0x00a5  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.


#define DMC_AXI10_CHAN_CTRL                        ((0x00a8  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI10_HOLD_CTRL                        ((0x00a9  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
#define DMC_AXI10_CHAN_CTRL1                       ((0x00aa  << 2) + 0xff638000)
  //bit 11  Mali/NNA channel FIQ controlled super urgent enable.
  //bit 10  Mali/NNA channel FIQ controlled urgent enable.
  //bit  9. Mali/NNA channel IRQ controlled super urgent enable.
  //bit  8. Mali/NNA channel IRQ controlled urgent enable.
  //bit  7.  IRQ/FIQ controll enable.
  //bit  6:0.  not used.

#define DMC_AXI11_CHAN_CTRL                        ((0x00ac  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight

#define DMC_AXI11_HOLD_CTRL                        ((0x00ad  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI12_CHAN_CTRL                        ((0x00b0  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI12_HOLD_CTRL                        ((0x00b1  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_AXI13_CHAN_CTRL                        ((0x00b4  << 2) + 0xff638000)
  //bit 31       enable to incr 2 urgent levels if the pending cycles is doubled.
  //bit 30       enable to incr 3 urgent levels.
  //bit 29:20.   write request pending cycle number  to inc urgent level if not granted.
  //bit 19.      axi0 default urgent control : 1 use AWUGT/ARUGT pins in the port. 0 : use bit[15:14] of this register..
  //bit 18.      force this channel all request to be super urgent request.
  //bit 17.      force this channel all request to be urgent request.
  //bit 16.      force this channel all request to be non urgent request.
  //bit 15:14    axi1 default urgent level.
  //bit 13:4.    read request pending cycle number  to inc urgent level if not granted.
  //bit 3:0      canvas arbiter arbiter weight
#define DMC_AXI13_HOLD_CTRL                        ((0x00b5  << 2) + 0xff638000)
    //31:24 write hold num.   max outstanding request number.
    //23:16  write hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.
    //15:8 read hold num.   max outstanding request number.
    //7:0  read hold release num. if the outstanding request == hold num, then hold this request unless the outstanding request number bellow the hold release number, then continue to request.

#define DMC_CHAN_STS                               ((0x00bc  << 2) + 0xff638000)
  //AXI0  is first CPU and Mali conbined channel from CCI-400 directly.  The first 2Gbyte address will go through this channel.
  //AXI10  is the second CPU, Mali channel combined with NNA  from NIC-400.  The upper 2Gbyte address will go through this channel.
  // read only regsiter.
  // the second mali and NNA channel IDLE.
  // the second CPU channel IDLE.
  // the first mali channel IDLE.
  // the first CPU channel IDLE.
  //bit 27      always 1
  //bit 26      ddr0 write data buffer idle. 1 : idle 0: busy.
  //bit 25      always 1.
  //bit 24      ddr0 wbuf idle.              1 : idle 0: busy.
  //bit 23:16   ambus channel idle.          1 : idle 0: busy.
  //bit 15:0.   axibus channel idle.         1 : idle 0: busy.

#define DMC_PROT0_RANGE                            ((0x00d0  << 2) + 0xff638000)
  //protection 0 address range. the range define is 64Kbyte boundary.  current address [31:16] >= start address && current address [31:16] <= end address.
  //bit 31:16 :   range end address.
  //bit 15:0  :   range start address
#define DMC_PROT0_CTRL                             ((0x00d1  << 2) + 0xff638000)
  //bit 23:16. each bit to eanble one of the 8 ambus channal for the protection function.
  //bit 15:0   each bit to enable one of the 15 channel input for the protection function.
#define DMC_PROT0_CTRL1                            ((0x00d2  << 2) + 0xff638000)
  //bit 26.  protection 0  read access protection enable.
  //bit 25.  protection 0  write access block function. if enabled, the access wouldn't write to the DDR SDRAM.  if not enabled only generate a interrupt, but the access still wrote to DDR.
  //bit 24.  protection range 0  write access protection enable.
#define DMC_PROT1_RANGE                            ((0x00d3  << 2) + 0xff638000)
  //protection 1 address range. the range define is 64Kbyte boundary.  current address [31:16] >= start address && current address [31:16] <= end address.
  //bit 31:16 :   range end address.
  //bit 15:0  :   range start address
#define DMC_PROT1_CTRL                             ((0x00d4  << 2) + 0xff638000)
  //bit 23:16. each bit to eanble one of the 8 ambus channal for the protection function.
  //bit 15:0   each bit to enable one of the 15 channel input for the protection function.
#define DMC_PROT1_CTRL1                            ((0x00d5  << 2) + 0xff638000)
  //bit 26.  protection range 1 read access protection enable bit.
  //bit 25.  protection 1  write access block function. if enabled, the access wouldn't write to the DDR SDRAM.  if not enabled only generate a interrupt, but the access still wrote to DDR.
  //bit 24.  protection range 1 write access protection enable bit.

#define DMC_PROT_VIO_0                             ((0x00d6  << 2) + 0xff638000)
  //ddr0 write proection violation address.
#define DMC_PROT_VIO_1                             ((0x00d7  << 2) + 0xff638000)
  //bit 31:21 . not used. always 0.
  //20     ddr0 protection 1 vilation.
  //19     ddr0 protection 0 vilation.
  //18:16. ddr0 write violation AWPROT bits.
  //15:0   ddr0_write violation ID.
#define DMC_PROT_VIO_2                             ((0x00d8  << 2) + 0xff638000)
  //ddr0 read prot violation address
#define DMC_PROT_VIO_3                             ((0x00d9  << 2) + 0xff638000)
  //bit 31:21 . not used. always 0.
  //20     ddr0 read protection 1 violation.
  //19     ddr0 read protection 0 violation.
  //18:16. ddr0 read violation ARPROT bits.
  //15:0   ddr0 read violation ID.
#define DMC_PROT_IRQ_CTRL                          ((0x00da  << 2) + 0xff638000)
  //bit 2 :  protect function IRQ enable.
  //bit 1 :  write protection violation.  write 1 to clean write protection vio registers.
  //bit 0 :  read  protection violation.  write 1 to clean read protection vio registers.

#define DMC_IRQ_STS                                ((0x00db  << 2) + 0xff638000)
  //bit 31:3   Not used.
  //bit 2 :    QOS Monitor interrupt flag.  1: means there's QOS monitor interrup.  write 1 to clean this interrupt.
  //bit 1 :    WRITE protection interrupt.  1: means there's write protection violation.  need to write DMC_PROT_IRQ_CTRL  bit 1to clean this bit.
  //bit 0 :    read protection interrupt.   1: means there's read  protection violation.  need to write DMC_PROT_IRQ_CTRL bit 0 to clean this bit.

// -----------------------------------------------
// REG_BASE:  DMC_TEST_REG_BASE = 0xff639800
// -----------------------------------------------

#define DMC_TEST_STA                               ((0x0000  << 2) + 0xff639800)
  //test start address.  for non-sha mode,  the last 5 bits would be ignored. the test address at 32bytes boundary.
  //                     for sha mode,      address must be in 64 bytes boundary. that mean the last 6 bits must be 0.

#define DMC_TEST_EDA                               ((0x0001  << 2) + 0xff639800)
  //test end address.  for non-sha mode,  the last 5 bits would be ignored. the test address at 32bytes boundary.
  //                   for sha mode,       address must be in 64 bytes boundary. that mean the last 6bits must be 1.
#define DMC_TEST_CTRL                              ((0x0002  << 2) + 0xff639800)
   //bit 31.  enable test.
   //bit 30.  when enable test, enable the write to DDR function.
   //bit 29.  when enable test, enable the read from DDR function.
   //bit 28.  when enable test,  enable the sha calculation function  must be same as read enable but without write function.
   //bit 27.  enabe to compare data.  when do the read enable to enable the error comparaion. suppose the read data should be same as the data in the write buffer.
   //bit 26.  0: save sha result to test_sha_message registers.  1 : don't save.
   //bit 25.  address generation type.  0: continuous increase the address in the range of test start address and test end address.
   //                                   1: test module would pick the random address from test start address  and test end address.
   //bit 24.  done type.      0 : use the DMC_TEST_NUM register as the counter of test numbers.
   //                             for write if the write command number == the DMC_TEST_NUM, the write is done.
   //                             for read if the read command number == the DMC TEST_num, the read id done. for one read command can be repeated repeat number times.
   //                         1 : finshed at end address.
   //bit 23.  wdata type.     1 : the first write is {WD3, WD2,WD1,WD0}, then the latter is the previous data plus a pattern.( { + WD7,  + WD6, + WD5, + WD4}).
   //                         0 : the WDATA is the data in write register.
   //bit 23.  1  compare the sha result with the test sha message registers. 0 : dont compare the result.
   //bit 22:20.   read repeat times.  for non-sha function, we can define multi times of the read. the test module would repeat the same adddress repeat times.
   //bit 19.     limit write.  0: no outstanding write request limitation.
   //                          1: limit the outstanding write commands to the number of bits [15:8]
   //bit 18.     limit read.   0. no outstanding read request limitation.
   //                          1. limit the read outstanding request to the number of bits[7:0].
   //bit 17:16.  sha mode for sha function enabled.  00 : not used.  01 : sha1. 2: sha2-256. 3: sha2_224. not used in GXL fixed to be  Sha 2.
   //bit 15:8.   write outstanding commands limit.
   //bit 7:0.    read  outstanding commands limit.

#define DMC_TEST_NUM                               ((0x0003  << 2) + 0xff639800)
   // how many test command for the test if the DMC_TEST_CTRL bit 24 is 0.

#define DMC_TEST_WDG                               ((0x0004  << 2) + 0xff639800)
  //31:16.  write response watch dog.
  //15:0.   read response  watch dog.

#define DMC_TEST_COMP_MASK                         ((0x0005  << 2) + 0xff639800)
  //32bits for DMC TEST COMPARE bit enable.
  //1 : to MASK this bit.  0: compare this bit.

#define DMC_TEST_WSTRB0                            ((0x0006  << 2) + 0xff639800)
  //MPC WR FIFO command DM bit write data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.

#define DMC_TEST_WSTRB1                            ((0x0007  << 2) + 0xff639800)
  //MPC WR FIFO command DM bit write data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.


#define DMC_TEST_WD0                               ((0x0010  << 2) + 0xff639800)
   // write data 0 for write command. also for read back data comparision.
#define DMC_TEST_WD1                               ((0x0011  << 2) + 0xff639800)
   // write data 1 for write command. also for read back data comparision.
#define DMC_TEST_WD2                               ((0x0012  << 2) + 0xff639800)
   // write data 2 for write command. also for read back data comparision.
#define DMC_TEST_WD3                               ((0x0013  << 2) + 0xff639800)
   // write data 3 for write command. also for read back data comparision.
#define DMC_TEST_WD4                               ((0x0014  << 2) + 0xff639800)
   // write data 4 for write command. also for read back data comparision.
#define DMC_TEST_WD5                               ((0x0015  << 2) + 0xff639800)
   // write data 5 for write command. also for read back data comparision.
#define DMC_TEST_WD6                               ((0x0016  << 2) + 0xff639800)
   // write data 6 for write command. also for read back data comparision.
#define DMC_TEST_WD7                               ((0x0017  << 2) + 0xff639800)
   // write data 7 for write command. also for read back data comparision.
#define DMC_TEST_WD8                               ((0x0018  << 2) + 0xff639800)
   // write data 8 for write command. also for read back data comparision.
#define DMC_TEST_WD9                               ((0x0019  << 2) + 0xff639800)
   // write data 9 for write command. also for read back data comparision.
#define DMC_TEST_WD10                              ((0x001a  << 2) + 0xff639800)
   // write data 10 for write command. also for read back data comparision.
#define DMC_TEST_WD11                              ((0x001b  << 2) + 0xff639800)
   // write data 11 for write command. also for read back data comparision.
#define DMC_TEST_WD12                              ((0x001c  << 2) + 0xff639800)
   // write data 12 for write command. also for read back data comparision.
#define DMC_TEST_WD13                              ((0x001d  << 2) + 0xff639800)
   // write data 13 for write command. also for read back data comparision.
#define DMC_TEST_WD14                              ((0x001e  << 2) + 0xff639800)
   // write data 14 for write command. also for read back data comparision.
#define DMC_TEST_WD15                              ((0x001f  << 2) + 0xff639800)
   // write data 15 for write command. also for read back data comparision.

#define DMC_TEST_RD0                               ((0x0020  << 2) + 0xff639800)
   // the read back data 0.  if error happens, it would capture the first error data.
#define DMC_TEST_RD1                               ((0x0021  << 2) + 0xff639800)
   // the read back data 1.  if error happens, it would capture the first error data.
#define DMC_TEST_RD2                               ((0x0022  << 2) + 0xff639800)
   // the read back data 2.  if error happens, it would capture the first error data.
#define DMC_TEST_RD3                               ((0x0023  << 2) + 0xff639800)
   // the read back data 3.  if error happens, it would capture the first error data.
#define DMC_TEST_RD4                               ((0x0024  << 2) + 0xff639800)
   // the read back data 4.  if error happens, it would capture the first error data.
#define DMC_TEST_RD5                               ((0x0025  << 2) + 0xff639800)
   // the read back data 5.  if error happens, it would capture the first error data.
#define DMC_TEST_RD6                               ((0x0026  << 2) + 0xff639800)
   // the read back data 6.  if error happens, it would capture the first error data.
#define DMC_TEST_RD7                               ((0x0027  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD8                               ((0x0028  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD9                               ((0x0029  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD10                              ((0x002a  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD11                              ((0x002b  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD12                              ((0x002c  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD13                              ((0x002d  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD14                              ((0x002e  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.
#define DMC_TEST_RD15                              ((0x002f  << 2) + 0xff639800)
   // the read back data 7.  if error happens, it would capture the first error data.


#define DMC_TEST_ERR_ADDR                          ((0x0040  << 2) + 0xff639800)
  //read only. it capature the first error address.
#define DMC_TEST_ERR_CNT                           ((0x0041  << 2) + 0xff639800)
  //read only. how many data error happens in the whole test period.
#define DMC_TEST_STS                               ((0x0042  << 2) + 0xff639800)
  //read only.
  //bit 31,   test done bit. write 1 to clean.
  //bit 30,   indicate address err
  //bit 29~7.  not used.
  //bit 6.    read data resp error(caused by security or rd latency).
  //bit 5.    test MRR/MPR rd latency error. write 1 clear
  //bit 4,    sha done.     write 1 to clean.
  //bit 3,    write done.   write 1 to clean.
  //bit 2,    read done.    write 1 to clean
  //bit 1,    write watchdog triggered.   write 1 to clean
  //bit 0,    read watchdog triggered.    write 1 to clean.

#define DMC_TEST_WRCMD_ADDR                        ((0x0043  << 2) + 0xff639800)
  //read only. the current write cmd address.
#define DMC_TEST_RDCMD_ADDR                        ((0x0044  << 2) + 0xff639800)
   //read only. the current read command address.
#define DMC_TEST_RDRSP_ADDR                        ((0x0045  << 2) + 0xff639800)
  //read only. the failed read response address(for error data )




//
// Closing file:  ../mmc_lp4/dmc/rtl/dmc_reg.vh
//
//
// Reading file:  ../mmc_lp4/dmc/rtl/dmc_sec.vh
//
// -----------------------------------------------
// REG_BASE:  DMC_SEC_REG_BASE = 0xff639000
// -----------------------------------------------

//DMC use 15bits ID to identify the input ports and ID.
// bit 14:10.
// 0 : CPU and MALI.   Mali and cpu will be seperated to 2 channel. CPU traffic will be assigned to ID = 0. Mali traffic will assigned to ID =1.
// 1 : Mali
// 2 : PCIE
// 3 : HDMI.
// 4 : HEVC_F.
// 5 : TEST.
// 6 : USB
// 7 : Device.
// 8 : HEVC_B
// 9 : WAVE.
//10 : CPU, GPU and NNA. CPU will assign to ID = 13.  GPU and NNA still in ID = 10. we use the GPU/NNA ID to cotrol the secure control.
//11 : GDC.
//12 : ISP.

// 15:13    Not used.
// 16:  VPU read 0.
// 17:  VPU read 1.
// 18: VPU read 2.
// 19: VPU write 0.
// 20: VPU write 1.
// 21: VDEC.
// 22: HCODEC.
// 23: ge2d.

//control bit for  SubID functions for all the input.
// ARM   2 bit.    HPROT[1] == 0 : SECURE CPU;   HPROT[1] == 1 : NONSEC CPU.
// GPU   2 bit.    HPROT[2] == 1 : SECURE GPU;   HPROT[2] == 0 : NONSEC GPU access;
// PCIE  1 bit.
// HDCP  2 bits.   ID AR/AWID[0].
// HEVC_F  9 bits. dc_id_in[7:4] == 0 : for IMEM. dc_id_in[7:4] == 1 : for PMEM. dc_id_in[7:5]  != 0 for other 7 types.
// TEST  1 type.
// USB   1 type.
// DEVICE  AO_CPU : AR/AWID[7:3] == 4'ha.  4bits control.   use AR/WID[1:0].
//         DMA    : AR/AWID[7:3] == 4'h2.  8bits control    use AR/WID[3:1].
//         AUDIO  : AR/AWID[7:3] == 4'h6.  16bits control.  use AR/AWID[3:0].
//         the others total 13 bits use AR/AWID[7:3] - (4'ha, 4'h2 and 4'h6).
//VPU read port 0 and read port 2. total 16bits. use ARID[3:0] (number 0~15).
//VPU read port 1.  total 8bits.   use ARID[3:0] (number 0~7).
//VPU write port 0  total 16bits.  use AWID[3:0] (number 0~16).
//VPU write port 1  total 8bits.   use AWID[3:0] (number 0~7).
//VDEC  total 16bits.  use AR/WID[5:2]
//HCODEC total 16bits. use AR/WID[5:2].
//GE2D.  total 3bits.  2 read bits, check ARID[0].  1 write bit.   AWID dont care.
//HEVC_B.  8 bits.  use AR/WID[7:5].
//NNA.    AR/WPROT[1] == 0:  secure access.  AR/WPROT[1] == 1: None secure access.
//GDC.   4bits for AR/AWID[5:4]. actuall for write there's only 1 ID. AWID[5:4] always 0.
//ISP.   one channel.

//there's total 16 ranges in the whole memory range.
// 15 ranges can be defined in 64kbyte boundary start address and end address.
// the 16th range is all other space not defined by 15 ranges.
// Each range can be enabled or disabled and  each range use security level bit to select key to do data scramble.
// The ranges can be overlapped or crossover.  But from 0 to 15 ranges, the earlier has higher priority.


#define DMC_SEC_RANGE0_CTRL                        ((0x0000  << 2) + 0xff639000)
  //bit 31:16   | 0 | range0_eda | range 0 end address  higher 16bits.
  //bit 15:0    | 0 | range0_sta | range 0 start address higher 16bits.
#define DMC_SEC_RANGE0_CTRL1                       ((0x0001  << 2) + 0xff639000)
  //bit 7:5 | 0 | range0_secrity_level | range0 secruity level for DMC and DEMUX only.
  //bit 4  | 0 | range0_prot_en       | range0 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range0_local_des_en  | range0 data describle enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES_EN to decide this region data describle enable or not.
  //bit 2  | 0 | range0_lock  |  lock range 0 registers. write 1 to lock range 0 register. can't change anymore.
  //bit 1  | 0 | range0_key_sel | range 0 data describle key selection.  1 : key1. 0 : key0.
  //bit 0  | 0 | range0_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE1_CTRL                        ((0x0002  << 2) + 0xff639000)
  //bit 31:16   | 0 | range1_eda | range 1 end address  higher 16bits.
  //bit 15:0    | 0 | range1_sta | range 1 start address higher 16bits.
#define DMC_SEC_RANGE1_CTRL1                       ((0x0003  << 2) + 0xff639000)
  //bit 7:5 | 0 | range1_secrity_level | range1 secruity level for DMC and DEMUX only.
  //bit 4  | 0 | range1_prot_en       | range1 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range1_local_des_en  | range1 data describle enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES_EN to decide this region data describle enable or not.
  //bit 2  | 0 | range1_lock  |  lock range 1 registers. write 1 to lock range 1 register. can't change anymore.
  //bit 1  | 0 | range1_key_sel | range 1 data describle key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range1_en    | range 0 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE2_CTRL                        ((0x0004  << 2) + 0xff639000)
  //bit 31:16   | 0 | range2_eda | range 2 end address  higher 16bits.
  //bit 15:0    | 0 | range2_sta | range 2 start address higher 16bits.
#define DMC_SEC_RANGE2_CTRL1                       ((0x0005  << 2) + 0xff639000)
  //bit 7:5 | 0 | range2_secrity_level | range2 secruity level for DMC and DEMUX only.
  //bit 4  | 0 | range2_prot_en       | range2 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range2_local_des_en  | range2 data describle enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES to decide this region data describle enable or not.
  //bit 2  | 0 | range2_lock  |  lock range 2 registers. write 1 to lock range 2 register. can't change anymore.
  //bit 1  | 0 | range2_key_sel | range 2 data describle key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range2_en    | range 2 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE3_CTRL                        ((0x0006  << 2) + 0xff639000)
  //bit 31:16   | 0 | range3_eda | range 3 end address  higher 16bits.
  //bit 15:0    | 0 | range3_sta | range 3 start address higher 16bits.
#define DMC_SEC_RANGE3_CTRL1                       ((0x0007  << 2) + 0xff639000)
  //bit 7:5 | 0 | range3_secrity_level | range3 secruity level for DMC and DEMUX only.
  //bit 4  | 0 | range3_prot_en       | range3 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range3_local_des_en  | range3 data describle enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES to decide this region data describle enable or not.
  //bit 2  | 0 | range3_lock    | lock range 3 registers. write 1 to lock range 3 related registers. can't change anymore.
  //bit 1  | 0 | range3_key_sel | range 3 data describle key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range3_en      | range 3 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE4_CTRL                        ((0x0008  << 2) + 0xff639000)
  //bit 31:16   | 0 | range4_eda | range 4 end address  higher 16bits.
  //bit 15:0    | 0 | range4_sta | range 4 start address higher 16bits.
#define DMC_SEC_RANGE4_CTRL1                       ((0x0009  << 2) + 0xff639000)
  //bit 7:5 | 0 | range4_secrity_level | range4 secruity level for DMC and DEMUX only.
  //bit 4  | 0 | range4_prot_en       | range4 allow protect monitor function.  1: allowed.  0: not allowed.
  //bit 3  | 0 | range4_local_des_en  | range4 data describle enable.  1: enable. 0 : disable. this bit works together with GLOBAL_DES to decide this region data describle enable or not.
  //bit 2  | 0 | range4_lock    | lock range 4 registers. write 1 to lock range 4 related registers. can't change anymore.
  //bit 1  | 0 | range4_key_sel | range 4 data describle key selection.  1 : key1. 1 : key0.
  //bit 0  | 0 | range4_en      | range 4 enable bit. 1 : enable, 0 : disable.
#define DMC_SEC_RANGE5_CTRL                        ((0x000a  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_CTRL1                       ((0x000b  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_CTRL                        ((0x000c  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_CTRL1                       ((0x000d  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_CTRL                        ((0x000e  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_CTRL1                       ((0x000f  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_CTRL                        ((0x0010  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_CTRL1                       ((0x0011  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_CTRL                        ((0x0012  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_CTRL1                       ((0x0013  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_CTRL                       ((0x0014  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_CTRL1                      ((0x0015  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_CTRL                       ((0x0016  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_CTRL1                      ((0x0017  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_CTRL                       ((0x0018  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_CTRL1                      ((0x0019  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_CTRL                       ((0x001a  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_CTRL1                      ((0x001b  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_CTRL                       ((0x001c  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_CTRL1                      ((0x001d  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_CTRL1                      ((0x001f  << 2) + 0xff639000)

//per range per sub ID access enable.
#define DMC_SEC_RANGE0_RID_CTRL0                   ((0x0020  << 2) + 0xff639000)
  //range_rd_sid_en[31:0];
#define DMC_SEC_RANGE0_RID_CTRL1                   ((0x0021  << 2) + 0xff639000)
  //range_rd_sid_en[63:32];
#define DMC_SEC_RANGE0_RID_CTRL2                   ((0x0022  << 2) + 0xff639000)
  //range_rd_sid_en[95:64];
#define DMC_SEC_RANGE0_RID_CTRL3                   ((0x0023  << 2) + 0xff639000)
  //range_rd_sid_en[127:96];
#define DMC_SEC_RANGE0_RID_CTRL4                   ((0x0024  << 2) + 0xff639000)

#define DMC_SEC_RANGE1_RID_CTRL0                   ((0x0026  << 2) + 0xff639000)
#define DMC_SEC_RANGE1_RID_CTRL1                   ((0x0027  << 2) + 0xff639000)
#define DMC_SEC_RANGE1_RID_CTRL2                   ((0x0028  << 2) + 0xff639000)
#define DMC_SEC_RANGE1_RID_CTRL3                   ((0x0029  << 2) + 0xff639000)
#define DMC_SEC_RANGE1_RID_CTRL4                   ((0x002a  << 2) + 0xff639000)

#define DMC_SEC_RANGE2_RID_CTRL0                   ((0x002c  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_RID_CTRL1                   ((0x002d  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_RID_CTRL2                   ((0x002e  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_RID_CTRL3                   ((0x002f  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_RID_CTRL4                   ((0x0030  << 2) + 0xff639000)

#define DMC_SEC_RANGE3_RID_CTRL0                   ((0x0032  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_RID_CTRL1                   ((0x0033  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_RID_CTRL2                   ((0x0034  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_RID_CTRL3                   ((0x0035  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_RID_CTRL4                   ((0x0036  << 2) + 0xff639000)

#define DMC_SEC_RANGE4_RID_CTRL0                   ((0x0038  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_RID_CTRL1                   ((0x0039  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_RID_CTRL2                   ((0x003a  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_RID_CTRL3                   ((0x003b  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_RID_CTRL4                   ((0x003c  << 2) + 0xff639000)

#define DMC_SEC_RANGE5_RID_CTRL0                   ((0x003e  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_RID_CTRL1                   ((0x003f  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_RID_CTRL2                   ((0x0040  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_RID_CTRL3                   ((0x0041  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_RID_CTRL4                   ((0x0042  << 2) + 0xff639000)

#define DMC_SEC_RANGE6_RID_CTRL0                   ((0x0044  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_RID_CTRL1                   ((0x0045  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_RID_CTRL2                   ((0x0046  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_RID_CTRL3                   ((0x0047  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_RID_CTRL4                   ((0x0048  << 2) + 0xff639000)

#define DMC_SEC_RANGE7_RID_CTRL0                   ((0x004a  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_RID_CTRL1                   ((0x004b  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_RID_CTRL2                   ((0x004c  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_RID_CTRL3                   ((0x004d  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_RID_CTRL4                   ((0x004e  << 2) + 0xff639000)

#define DMC_SEC_RANGE8_RID_CTRL0                   ((0x0050  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_RID_CTRL1                   ((0x0051  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_RID_CTRL2                   ((0x0052  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_RID_CTRL3                   ((0x0053  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_RID_CTRL4                   ((0x0054  << 2) + 0xff639000)

#define DMC_SEC_RANGE9_RID_CTRL0                   ((0x0056  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_RID_CTRL1                   ((0x0057  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_RID_CTRL2                   ((0x0058  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_RID_CTRL3                   ((0x0059  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_RID_CTRL4                   ((0x005a  << 2) + 0xff639000)

#define DMC_SEC_RANGE10_RID_CTRL0                  ((0x005c  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_RID_CTRL1                  ((0x005d  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_RID_CTRL2                  ((0x005e  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_RID_CTRL3                  ((0x005f  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_RID_CTRL4                  ((0x0060  << 2) + 0xff639000)

#define DMC_SEC_RANGE11_RID_CTRL0                  ((0x0062  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_RID_CTRL1                  ((0x0063  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_RID_CTRL2                  ((0x0064  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_RID_CTRL3                  ((0x0065  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_RID_CTRL4                  ((0x0066  << 2) + 0xff639000)

#define DMC_SEC_RANGE12_RID_CTRL0                  ((0x0068  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_RID_CTRL1                  ((0x0069  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_RID_CTRL2                  ((0x006a  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_RID_CTRL3                  ((0x006b  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_RID_CTRL4                  ((0x006c  << 2) + 0xff639000)

#define DMC_SEC_RANGE13_RID_CTRL0                  ((0x006e  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_RID_CTRL1                  ((0x006f  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_RID_CTRL2                  ((0x0070  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_RID_CTRL3                  ((0x0071  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_RID_CTRL4                  ((0x0072  << 2) + 0xff639000)

#define DMC_SEC_RANGE14_RID_CTRL0                  ((0x0074  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_RID_CTRL1                  ((0x0075  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_RID_CTRL2                  ((0x0076  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_RID_CTRL3                  ((0x0077  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_RID_CTRL4                  ((0x0078  << 2) + 0xff639000)

#define DMC_SEC_RANGE15_RID_CTRL0                  ((0x007a  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_RID_CTRL1                  ((0x007b  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_RID_CTRL2                  ((0x007c  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_RID_CTRL3                  ((0x007d  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_RID_CTRL4                  ((0x007e  << 2) + 0xff639000)

//per range per sub ID access enable.
#define DMC_SEC_RANGE0_WID_CTRL0                   ((0x0080  << 2) + 0xff639000)
#define DMC_SEC_RANGE0_WID_CTRL1                   ((0x0081  << 2) + 0xff639000)
#define DMC_SEC_RANGE0_WID_CTRL2                   ((0x0082  << 2) + 0xff639000)
#define DMC_SEC_RANGE0_WID_CTRL3                   ((0x0083  << 2) + 0xff639000)
#define DMC_SEC_RANGE0_WID_CTRL4                   ((0x0084  << 2) + 0xff639000)

#define DMC_SEC_RANGE1_WID_CTRL0                   ((0x0086  << 2) + 0xff639000)
#define DMC_SEC_RANGE1_WID_CTRL1                   ((0x0087  << 2) + 0xff639000)
#define DMC_SEC_RANGE1_WID_CTRL2                   ((0x0088  << 2) + 0xff639000)
#define DMC_SEC_RANGE1_WID_CTRL3                   ((0x0089  << 2) + 0xff639000)
#define DMC_SEC_RANGE1_WID_CTRL4                   ((0x008a  << 2) + 0xff639000)

#define DMC_SEC_RANGE2_WID_CTRL0                   ((0x008c  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_WID_CTRL1                   ((0x008d  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_WID_CTRL2                   ((0x008e  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_WID_CTRL3                   ((0x008f  << 2) + 0xff639000)
#define DMC_SEC_RANGE2_WID_CTRL4                   ((0x0090  << 2) + 0xff639000)

#define DMC_SEC_RANGE3_WID_CTRL0                   ((0x0092  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_WID_CTRL1                   ((0x0093  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_WID_CTRL2                   ((0x0094  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_WID_CTRL3                   ((0x0095  << 2) + 0xff639000)
#define DMC_SEC_RANGE3_WID_CTRL4                   ((0x0096  << 2) + 0xff639000)

#define DMC_SEC_RANGE4_WID_CTRL0                   ((0x0098  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_WID_CTRL1                   ((0x0099  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_WID_CTRL2                   ((0x009a  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_WID_CTRL3                   ((0x009b  << 2) + 0xff639000)
#define DMC_SEC_RANGE4_WID_CTRL4                   ((0x009c  << 2) + 0xff639000)

#define DMC_SEC_RANGE5_WID_CTRL0                   ((0x009e  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_WID_CTRL1                   ((0x009f  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_WID_CTRL2                   ((0x00a0  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_WID_CTRL3                   ((0x00a1  << 2) + 0xff639000)
#define DMC_SEC_RANGE5_WID_CTRL4                   ((0x00a2  << 2) + 0xff639000)

#define DMC_SEC_RANGE6_WID_CTRL0                   ((0x00a4  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_WID_CTRL1                   ((0x00a5  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_WID_CTRL2                   ((0x00a6  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_WID_CTRL3                   ((0x00a7  << 2) + 0xff639000)
#define DMC_SEC_RANGE6_WID_CTRL4                   ((0x00a8  << 2) + 0xff639000)

#define DMC_SEC_RANGE7_WID_CTRL0                   ((0x00aa  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_WID_CTRL1                   ((0x00ab  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_WID_CTRL2                   ((0x00ac  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_WID_CTRL3                   ((0x00ad  << 2) + 0xff639000)
#define DMC_SEC_RANGE7_WID_CTRL4                   ((0x00ae  << 2) + 0xff639000)

#define DMC_SEC_RANGE8_WID_CTRL0                   ((0x00b0  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_WID_CTRL1                   ((0x00b1  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_WID_CTRL2                   ((0x00b2  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_WID_CTRL3                   ((0x00b3  << 2) + 0xff639000)
#define DMC_SEC_RANGE8_WID_CTRL4                   ((0x00b4  << 2) + 0xff639000)

#define DMC_SEC_RANGE9_WID_CTRL0                   ((0x00b6  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_WID_CTRL1                   ((0x00b7  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_WID_CTRL2                   ((0x00b8  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_WID_CTRL3                   ((0x00b9  << 2) + 0xff639000)
#define DMC_SEC_RANGE9_WID_CTRL4                   ((0x00ba  << 2) + 0xff639000)

#define DMC_SEC_RANGE10_WID_CTRL0                  ((0x00bc  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_WID_CTRL1                  ((0x00bd  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_WID_CTRL2                  ((0x00be  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_WID_CTRL3                  ((0x00bf  << 2) + 0xff639000)
#define DMC_SEC_RANGE10_WID_CTRL4                  ((0x00c0  << 2) + 0xff639000)

#define DMC_SEC_RANGE11_WID_CTRL0                  ((0x00c2  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_WID_CTRL1                  ((0x00c3  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_WID_CTRL2                  ((0x00c4  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_WID_CTRL3                  ((0x00c5  << 2) + 0xff639000)
#define DMC_SEC_RANGE11_WID_CTRL4                  ((0x00c6  << 2) + 0xff639000)

#define DMC_SEC_RANGE12_WID_CTRL0                  ((0x00c8  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_WID_CTRL1                  ((0x00c9  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_WID_CTRL2                  ((0x00ca  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_WID_CTRL3                  ((0x00cb  << 2) + 0xff639000)
#define DMC_SEC_RANGE12_WID_CTRL4                  ((0x00cc  << 2) + 0xff639000)

#define DMC_SEC_RANGE13_WID_CTRL0                  ((0x00ce  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_WID_CTRL1                  ((0x00cf  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_WID_CTRL2                  ((0x00d0  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_WID_CTRL3                  ((0x00d1  << 2) + 0xff639000)
#define DMC_SEC_RANGE13_WID_CTRL4                  ((0x00d2  << 2) + 0xff639000)

#define DMC_SEC_RANGE14_WID_CTRL0                  ((0x00d4  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_WID_CTRL1                  ((0x00d5  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_WID_CTRL2                  ((0x00d6  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_WID_CTRL3                  ((0x00d7  << 2) + 0xff639000)
#define DMC_SEC_RANGE14_WID_CTRL4                  ((0x00d8  << 2) + 0xff639000)

#define DMC_SEC_RANGE15_WID_CTRL0                  ((0x00da  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_WID_CTRL1                  ((0x00db  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_WID_CTRL2                  ((0x00dc  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_WID_CTRL3                  ((0x00dd  << 2) + 0xff639000)
#define DMC_SEC_RANGE15_WID_CTRL4                  ((0x00de  << 2) + 0xff639000)


#define DMC_DES_PADDING                            ((0x00e0  << 2) + 0xff639000)
  //bit 31:0 | 0 | des_pading | 32bits address padding used for DES dkey generation.
#define DMC_DES_CTRL                               ((0x00e1  << 2) + 0xff639000)
 //bit 31 : range15_des_en policy : 1 range15_des_en = range15_local_des_en && GLOBAL_DES_EN. 0 : range15_des_en = range15_local_des_en ||  GLOBAL_DES_EN.
 //bit 30 : range14_des_en policy : 1 range14_des_en = range14_local_des_en && GLOBAL_DES_EN. 0 : range14_des_en = range14_local_des_en ||  GLOBAL_DES_EN.
 //bit 29 : range13_des_en policy : 1 range13_des_en = range13_local_des_en && GLOBAL_DES_EN. 0 : range13_des_en = range13_local_des_en ||  GLOBAL_DES_EN.
 //bit 28 : range12_des_en policy : 1 range12_des_en = range12_local_des_en && GLOBAL_DES_EN. 0 : range12_des_en = range12_local_des_en ||  GLOBAL_DES_EN.
 //bit 27 : range11_des_en policy : 1 range11_des_en = range11_local_des_en && GLOBAL_DES_EN. 0 : range11_des_en = range11_local_des_en ||  GLOBAL_DES_EN.
 //bit 26 : range10_des_en policy : 1 range11_des_en = range10_local_des_en && GLOBAL_DES_EN. 0 : range10_des_en = range10_local_des_en ||  GLOBAL_DES_EN.
 //bit 25 : range9_des_en policy  : 1  range9_des_en =  range9_local_des_en && GLOBAL_DES_EN. 0 :  range9_des_en =  range9_local_des_en ||  GLOBAL_DES_EN.
 //bit 24 : range8_des_en policy  : 1  range8_des_en =  range8_local_des_en && GLOBAL_DES_EN. 0 :  range8_des_en =  range8_local_des_en ||  GLOBAL_DES_EN.
 //bit 23 : range7_des_en policy  : 1  range7_des_en =  range7_local_des_en && GLOBAL_DES_EN. 0 :  range7_des_en =  range7_local_des_en ||  GLOBAL_DES_EN.
 //bit 22 : range6_des_en policy  : 1  range6_des_en =  range6_local_des_en && GLOBAL_DES_EN. 0 :  range6_des_en =  range6_local_des_en ||  GLOBAL_DES_EN.
 //bit 21 : range5_des_en policy  : 1  range5_des_en =  range5_local_des_en && GLOBAL_DES_EN. 0 :  range5_des_en =  range5_local_des_en ||  GLOBAL_DES_EN.
 //bit 20 : range4_des_en policy  : 1  range4_des_en =  range4_local_des_en && GLOBAL_DES_EN. 0 :  range4_des_en =  range4_local_des_en ||  GLOBAL_DES_EN.
 //bit 19 : range3_des_en policy  : 1  range3_des_en =  range3_local_des_en && GLOBAL_DES_EN. 0 :  range3_des_en =  range3_local_des_en ||  GLOBAL_DES_EN.
 //bit 18 : range2_des_en policy  : 1  range2_des_en =  range2_local_des_en && GLOBAL_DES_EN. 0 :  range2_des_en =  range2_local_des_en ||  GLOBAL_DES_EN.
 //bit 17 : range1_des_en policy  : 1  range1_des_en =  range1_local_des_en && GLOBAL_DES_EN. 0 :  range1_des_en =  range1_local_des_en ||  GLOBAL_DES_EN.
 //bit 16 : range0_des_en policy  : 1  range0_des_en =  range0_local_des_en && GLOBAL_DES_EN. 0 :  range0_des_en =  range0_local_des_en ||  GLOBAL_DES_EN.
 //bit 1 | 0 | GLOBAL_DES_EN |  1: Global DES enable. 0 : global DES disable.  default is 0.
 //bit 0 | 0 | DES_lock  |  one time lock bit. after write 1 to this bit, DMC_DES_CTRL,DMC_DES_PADDING  can't be write and read.


#define DMC_DES_KEY0_REG0                          ((0x00e2  << 2) + 0xff639000)
#define DMC_DES_KEY0_REG1                          ((0x00e3  << 2) + 0xff639000)
#define DMC_DES_KEY0_REG2                          ((0x00e4  << 2) + 0xff639000)
#define DMC_DES_KEY0_REG3                          ((0x00e5  << 2) + 0xff639000)
#define DMC_DES_KEY1_REG0                          ((0x00e6  << 2) + 0xff639000)
#define DMC_DES_KEY1_REG1                          ((0x00e7  << 2) + 0xff639000)
#define DMC_DES_KEY1_REG2                          ((0x00e8  << 2) + 0xff639000)
#define DMC_DES_KEY1_REG3                          ((0x00e9  << 2) + 0xff639000)

//trap function: all the enable the port ID read access or enable PORT ID and subID read access must be in the predefine range. otherwire the read access would be blocked.
// and an error will be generated.
#define DMC_TRAP0_RANGE                            ((0x00ea  << 2) + 0xff639000)
  // address trap0 range register.
  //31:16.  trap0  end address
  //15:0    start0 address.
#define DMC_TRAP0_CTRL                             ((0x00eb  << 2) + 0xff639000)
  //bit 31 trap0 port ID 3 enable.
  //bit 30 trap0 port ID 2 enable.
  //bit 29 trap0 port ID 1 enable.
  //bit 28 trap0 port ID 0 enable.
  //bit 27 trap0 port ID 3 subid enable.
  //bit 26 trap0 port ID 2 subid enable.
  //bit 25 trap0 port ID 1 subid enable.
  //bit 24 trap0 port ID 0 subid enable.
  //bit 16:20. trap0 port ID 1 ID number.
  //bit 14:11.  trap0 port ID 1 subID ID number.
  //bit 8:4.   trap0 port ID 0 ID number.
  //bit 3:0.   trap0 port ID 0 subID ID number.
#define DMC_TRAP0_CTRL2                            ((0x00ec  << 2) + 0xff639000)
  //bit 31:17. Not used.
  //bit 16:20. trap0 port ID 3 ID number.
  //bit 14:11. trap0 port ID 3 subID ID number.
  //bit 8:4.   trap0 port ID 2 ID number.
  //bit 3:0.   trap0 port ID 2 subID ID number.


#define DMC_TRAP1_RANGE                            ((0x00ed  << 2) + 0xff639000)
  //address trap range register.
  //31:16.  trap end address
  //15:0    start address.
#define DMC_TRAP1_CTRL                             ((0x00ee  << 2) + 0xff639000)
  //bit 31 trap1 port ID 3 enable.
  //bit 30 trap1 port ID 2 enable.
  //bit 29 trap1 port ID 1 enable.
  //bit 28 trap1 port ID 0 enable.
  //bit 27 trap1 port ID 3 subid enable.
  //bit 26 trap1 port ID 2 subid enable.
  //bit 25 trap1 port ID 1 subid enable.
  //bit 24 trap1 port ID 0 subid enable.
  //bit 16:20. trap1 port ID 1 ID number.
  //bit 14:11. trap1 port ID 1 subID ID number.
  //bit 8:4.   trap1 port ID 0 ID number.
  //bit 3:0.   trap1 port ID 0 subID ID number.

#define DMC_TRAP1_CTRL2                            ((0x00ef  << 2) + 0xff639000)
  //bit 31:17. Not used.
  //bit 16:20. trap1 port ID 1 ID number.
  //bit 14:11. trap1 port ID 1 subID ID number.
  //bit 8:4.   trap1 port ID 0 ID number.
  //bit 3:0.   trap1 port ID 0 subID ID number.


//APB secure control bits[3:0] .
    //bit 3.   1: All APB bus can access these domain registers.
    //         0: only if the apb access pprot[2:0]  match the bit [2:0], can access this domain registers.
#define DDR_APB_SEC_CTRL                           ((0x00f0  << 2) + 0xff639000)
    //bit 31:28:  APB secure control bits for protection register domain.
    //bit 27:24:  APB secure control bits for clok and reset register domain.
    //bit 23:20:  APB secure control bits for dmc test register domain.
    //bit 19:16.  APB secure control bits for dmc_reg register domain.
    //bit 15:12.  APB secure control bits for sticky register domain.
    //bit 11:8.   APB secure control bits for frequency change register domain.
    //Bit 7:4.    APB secure control bits for dram control register domain.
    //Bit 3:0.    APB secure control bits for DDR PHY register domain.
#define DDR_APB_SEC_CTRL1                          ((0x00f1  << 2) + 0xff639000)
    //bit 3:0.    APB secure control bits for dmc request register domain.



//registers to check the security protection and watch point error information.
#define DMC_SEC_STATUS                             ((0x00f2  << 2) + 0xff639000)
 //bit 31~2. not used.
 //bit 6
 //bit 5
 //bit 4
 //bit 3   1 : normal security register write violation.( APB bus WDATA not equre the register value when APB write).  write 1 to clean this bit to 0.
 //bit 2   sec_alert.   1 DMC secruity register alert function triggered. can't clean. only reset DMC can clear this bit.
 //bit 1   write security violation.
 //bit 0.  read security violation.

#define DMC_VIO_ADDR0                              ((0x00f3  << 2) + 0xff639000)
  //ddr0 write secure violation address.
#define DMC_VIO_ADDR1                              ((0x00f4  << 2) + 0xff639000)
  //bit 31:24 . not used. always 0.
  //24     ddr0 secure check violation.
  //23     not used.
  //22     not used.
  //21     not used.
  //20.    not used.
  //19     ddr0 write address overflow. write out of DDR size.
  //18:16. ddr0 write violation AWPROT bits.
  //15:0   ddr0_write violation ID.
#define DMC_VIO_ADDR2                              ((0x00f5  << 2) + 0xff639000)
  //ddr0 read seure violation address
#define DMC_VIO_ADDR3                              ((0x00f6  << 2) + 0xff639000)
  //24     ddr0 read secure check violation.
  //23     not used.
  //22     not used.
  //21     ddr0 read trap1 violation
  //20     ddr0 read trap0 violation
  //19     ddr 0 read address overflow. write out of DDR size.
  //18:16. ddr 0 read violation ARPROT bits.
  //15:0   ddr 0 read violation ID.


#define DMC_DDR_CTRL                               ((0x0100  << 2) + 0xff639000)
   //bit 27.   0 : cavnas use 64bytes boundary
              // 1 : canvas use 32bytes boundary.
  //bit 24:22   3'b000 : ddr3 mode.
              //3'b001 : ddr4 mode.
              //3'b010 : lpddr3 mode.
              //3'b011 : lpddr4 mode.
   //bit 21.   rank1 enable bit. if 1,  rank1 used the address map is as bit 5:3 defined.
   //bit 20    DDR4 BG1 enable bit.
   //bit 18:   ddrphy_16b, DDR PHY DDR SDRAM data bits width.  1: 16bits. 0 : 32 bits.
   //bit 16.   ddr_16b,   1: only use 16bits data in a 32bits DDR PHY data interface. 0 : normal data interface.
  //bit 7:4 :  ddr1_size.  DDR rank1 size control.
     //4'b0000 : DDR rank 1 is 128Mbyte.
     //4'b0001 : DDR rank 1 is 256Mbyte.
     //4'b0010 : DDR rank 1 is 512Mbyte.
     //4'b0011 : DDR rank 1 is 1Gbyte.
     //4'b0100 : DDR rank 1 is 2Gbyte.
     //4'b0101 : DDR rank 1 is 4Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 374Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.
  //bit 3:0  :  ddr0_size. DDR rank0 size control.
     //4'b0000 : DDR rank 0 is 128Mbyte.
     //4'b0001 : DDR rank 0 is 256Mbyte.
     //4'b0010 : DDR rank 0 is 512Mbyte.
     //4'b0011 : DDR rank 0 is 1Gbyte.
     //4'b0100 : DDR rank 0 is 2Gbyte.
     //4'b0101 : DDR rank 0 is 4Gbyte.
     //4'b1000 : DDR rank 1 is 192Mbyte.
     //4'b1001 : DDR rank 1 is 374Mbyte.
     //4'b1010 : DDR rank 1 is 768Mbyte.
     //4'b1011 : DDR rank 1 is 1.5Gbyte.
     //4'b1100 : DDR rank 1 is 3Gbyte.
     //others :  reserved.


//DDR3/4 LPDDR3/4 SDRAM address  to 32bits linear address address map:
//DDR0_ADDRMAP is used to select RANK0 bank, row, col address selection.
//DDR1_ADDRMAP is used to select RANK1 bank, row, col address selection.
#define DDR0_ADDRMAP_0                             ((0x0101  << 2) + 0xff639000)
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.

#define DDR0_ADDRMAP_1                             ((0x0102  << 2) + 0xff639000)
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.

#define DDR0_ADDRMAP_2                             ((0x0103  << 2) + 0xff639000)
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.

#define DDR0_ADDRMAP_3                             ((0x0104  << 2) + 0xff639000)
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.

#define DDR0_ADDRMAP_4                             ((0x0105  << 2) + 0xff639000)
  //29:25 ra16 for DDR4 SDRAM
  //24:20 bg1  for DDR4 SDRAM.
  //19:15 ba2.    or bg0 for DDR4.
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.


#define DDR1_ADDRMAP_0                             ((0x0106  << 2) + 0xff639000)
  //29:25 ca8.
  //24:20 ca7.
  //19:15 ca6.
  //14:10 ca5.
  //9:5   ca4.
  //4:0   ca3.

#define DDR1_ADDRMAP_1                             ((0x0107  << 2) + 0xff639000)
  //29:25 ra2.
  //24:20 ra1.
  //19:15 ra0.
  //14:10 ca11.
  //9:5   ca10.
  //4:0   ca9.

#define DDR1_ADDRMAP_2                             ((0x0108  << 2) + 0xff639000)
  //29:25 ra8.
  //24:20 ra7.
  //19:15 ra6.
  //14:10 ra5.
  //9:5   ra4.
  //4:0   ra3.

#define DDR1_ADDRMAP_3                             ((0x0109  << 2) + 0xff639000)
  //29:25 ra14.
  //24:20 ra13.
  //19:15 ra12.
  //14:10 ra11.
  //9:5   ra10.
  //4:0   ra9.

#define DDR1_ADDRMAP_4                             ((0x010a  << 2) + 0xff639000)
  //29:25 ra16 for DDR4 SDRAM
  //24:20 bg1  for DDR4 SDRAM.
  //19:15 ba2  or bg0 for DDR4 SDRAM..
  //14:10 ba1.
  //9:5   ba0.
  //4:0   ra15.

#define DDR_MEM_PD_CTRL                            ((0x010b  << 2) + 0xff639000)
   //bit 31:14 not used.
   //2 bit control for each mem. 00 normal working. 11 power down.
   //bit 13:12   wc_fifo
   //bit 11:10   wd_mem
   //bit 9:8     rd_mem
   //bit 7:6     dfifo
   //bit 5:4     cfifo
   //bit 3:2     cav_ram
   //bit 1:0     sticky ram


#define DMC_AXI2DDR0                               ((0x0120  << 2) + 0xff639000)
  //for AXI address first 256MB  AXI ADDRESS[31:28] == 4'b0000.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]

#define DMC_AXI2DDR1                               ((0x0121  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0001.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]

#define DMC_AXI2DDR2                               ((0x0122  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0010.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]

#define DMC_AXI2DDR3                               ((0x0123  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0011.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR4                               ((0x0124  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0100.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR5                               ((0x0125  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0101.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR6                               ((0x0126  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0110.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR7                               ((0x0127  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b0111.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR8                               ((0x0128  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1000.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDR9                               ((0x0129  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1001.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRA                               ((0x012a  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1010.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRB                               ((0x012b  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1011.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRC                               ((0x012c  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1100.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRD                               ((0x012d  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1101.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRE                               ((0x012e  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1110.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]
#define DMC_AXI2DDRF                               ((0x012f  << 2) + 0xff639000)
  //for AXI_ADDRESS[31:28] == 4'b1111.
  //bit 6  range_valid     1 : valid address 0 : not valid.
  //bit 5  rank_sel,       0 : rank0.   1: rank1.
  //bit 4  ddr_data_width, 0 : 32bits.  1: 16bits.
  //bti 3:0. remap to one rank of DDR SDRAM linear address[31:28]

#define DMC_DDR_CTRL1                              ((0x0130  << 2) + 0xff639000)
  //bit 0. DMC_DDR_LOCK.    1: LOCK DMC_DDR_CTRL, DMC_DDR_CTRL1, DMC_AXI2DDRx, DDR0/1_ADDRMAP_x registers. those register can't modified any more.
                        //  0: all these regsiters can be read/write by secure APB access.

//
// Closing file:  ../mmc_lp4/dmc/rtl/dmc_sec.vh
//
//
// Reading file:  ../mmc_lp4/dmc/rtl/dmc_siu_reg.vh
//
// -----------------------------------------------
// REG_BASE:  DMC_DRAM_REG_BASE = 0xff638400
// -----------------------------------------------
//there's 2 set of timing DDR timing parameter for 2 set of DDR freqency parameter.
//when change frequency, the hardware would automatically select one of these two set of timing parameter
//DMC_DRAM_* is for Frequency set 0.
//DMC_NFQ_* is for Freqency set 1.
#define DMC_DRAM_TMRD                              ((0x0000  << 2) + 0xff638400)
   //bit 4:0.  tMRD. //MR command cycles, in DDR3/4.  in LPDDR4, it should be value of tMRW
#define DMC_DRAM_TRFC                              ((0x0001  << 2) + 0xff638400)
   //bit 9:0 tRFC
#define DMC_DRAM_TRP                               ((0x0002  << 2) + 0xff638400)
   //bit 21:16.  tRP for precharge all banks.
   //bit 5:0.    tRP for precharge one bank.
#define DMC_DRAM_TRTW                              ((0x0003  << 2) + 0xff638400)
   //bit 31:6:   Not used.
   //bit 5:0     DDR3/4 mode : tRTW.
   // For LPDDR4 .  The total read command -> write command = (RL + BL/2 - tWODTON) + TDQSCK_MAX + tWPRE +RD(tRPST).
   //                 tRTW = TDQSCK_max + tWPRE + tRD(tRPST)  + (delay margin)
#define DMC_DRAM_TCL                               ((0x0004  << 2) + 0xff638400)
  //bit 5:0  tCL/tRL. read latency.
#define DMC_DRAM_TCWL                              ((0x0005  << 2) + 0xff638400)
  //bit 5:0.  CWL:  write latency.
#define DMC_DRAM_TRAS                              ((0x0006  << 2) + 0xff638400)
  //bit 7:0.  tRAS.  minimum active to precharge time for same bank.
#define DMC_DRAM_TRC                               ((0x0007  << 2) + 0xff638400)
  //bit 7:0.  tRC.  minimum active to active time for same bank.
#define DMC_DRAM_TRCD                              ((0x0008  << 2) + 0xff638400)
  //bit 7:0  tRCD  active to read/write timing for same bank.
#define DMC_DRAM_TRRD                              ((0x0009  << 2) + 0xff638400)
  //bit 21:16.  tRRD_l  active bank A to active B in same band group for DDR4.
  //bit 5:0.    tRRD/tRRD_s   active bank A to active bank b time.
              //tRRD_s:   active bank A to active bank b in different bank grousp for DDR4.
#define DMC_DRAM_TFAW                              ((0x000a  << 2) + 0xff638400)
  //bit 8:0   tFAW.  four active command windows
#define DMC_DRAM_TRTP                              ((0x000b  << 2) + 0xff638400)
  //bit 5:0  tRTP.
#define DMC_DRAM_TWR                               ((0x000c  << 2) + 0xff638400)
  //bit 5:0 tWR.
#define DMC_DRAM_TWTR                              ((0x000d  << 2) + 0xff638400)
  //bit 21:16 tWTR_l   For DDR4 WTR_l.  FOR DDR3/LPDDR4 same as tWTR_s.
  //bit 5:0 tWTR_s.
#define DMC_DRAM_TCCD                              ((0x000e  << 2) + 0xff638400)
  //bit 19:16. tCCD/tCCD_l.
  //bit 3:0 tCCD/tCCD_s    read to read command time or write to write command time.
#define DMC_DRAM_TEXSR                             ((0x000f  << 2) + 0xff638400)
  //bit 12:0. tEXSR.  EXIT SELF-REFRESH to read/write command.
#define DMC_DRAM_TXS                               ((0x0010  << 2) + 0xff638400)
  //bit 9:0  tXS.  EXIT SELF_REFRESH to other command time
#define DMC_DRAM_TXP                               ((0x0011  << 2) + 0xff638400)
  //bit 3:0. tXP.  EXIT power down to other command time
#define DMC_DRAM_TXPDLL                            ((0x0012  << 2) + 0xff638400)
  //bit 12:0.  tXPDLL,  EXIT power down to read/write command time(need to relock PLL).
#define DMC_DRAM_TZQCS                             ((0x0013  << 2) + 0xff638400)
  //bit 11:0.  ZQCS command to other command time.
#define DMC_DRAM_TCKSRE                            ((0x0014  << 2) + 0xff638400)
  //bit 4:0. enter self refresh to disable clock time.
#define DMC_DRAM_TCKSRX                            ((0x0015  << 2) + 0xff638400)
  //bit 4:0. enable clock to exit self refresh time.
#define DMC_DRAM_TCKE                              ((0x0016  << 2) + 0xff638400)
  //bit 4:0.  CKE high or low minimum time.
#define DMC_DRAM_TMOD                              ((0x0017  << 2) + 0xff638400)
  //bit 4:0  tMOD.  MRR/MRW to other command time. in LPDDR4, still use this register but it called tMRD.

#define DMC_DRAM_TDQS                              ((0x0018  << 2) + 0xff638400)
  //bit 31:28 reserved
  //bit 27:24 tDQS. the delay for write after read in different rank.
  //bit 23:20 reserved
  //bit 19:16 tDQS. the delay for read after write in different rank.
  //bit 15:12 reserved
  //bit 11:8  tDQS. the delay for write after write in different rank.
  //bit 7:4 reserved
  //bit 3:0 tDQS. the delay for read after read in different rank.
#define DMC_DRAM_TRSTL                             ((0x0019  << 2) + 0xff638400)
  //not used.
#define DMC_DRAM_TZQLAT                            ((0x001a  << 2) + 0xff638400)
  //bit 5:0 ZQ LATCH command to other comand timing in LPDDR4 mode.
#define DMC_DRAM_TMRR                              ((0x001b  << 2) + 0xff638400)
  //bit 7:0 tMRR  not used in DMC.

#define DMC_DRAM_TCKESR                            ((0x001c  << 2) + 0xff638400)
 //bit 9:0 tCKESR.   CKE low minimum pulse in self refresh mode.
#define DMC_DRAM_TDPD                              ((0x001d  << 2) + 0xff638400)
 //not support.
#define DMC_DRAM_DFITCTRLDELAY                     ((0x001e  << 2) + 0xff638400)
  //bit 3:0. DFI_t_ctrldealy
#define DMC_DRAM_DFITPHYWRDATA                     ((0x001f  << 2) + 0xff638400)
  //bit 5:0.  dfi_t_phy_wrdata.
#define DMC_DRAM_DFITPHYWRLAT                      ((0x0020  << 2) + 0xff638400)
  //bit 5:0.  dfi_t_phy_wrlat.  in DDR3/4/LPDDR3 mode:   WL -5.   in LPDDR4 mode: WL -5 + 2.
#define DMC_DRAM_DFITRDDATAEN                      ((0x0021  << 2) + 0xff638400)
  //bit 5:0.  dfi_t_rddata_en.  in DDR3/4/LPDDR3 mode: RL -5. in LPDDR4 mode : RL -5 + 1.
#define DMC_DRAM_DFITPHYRDLAT                      ((0x0022  << 2) + 0xff638400)
  //bit 5:0.  dfi_t_rdlat.
#define DMC_DRAM_DFITCTRLUPDMIN                    ((0x0023  << 2) + 0xff638400)
  //bit 7:0.  CTRLUPD_MIN  minimux clock cycle to maintain CTRLUPD_REQ.
#define DMC_DRAM_DFITCTRLUPDMAX                    ((0x0024  << 2) + 0xff638400)
  //bit 7:0   CTRLUPD_MAX.  maxmum clock cycle to maintain CTRLUPD_REQ if no CTRLUPD_ACK response.
#define DMC_DRAM_DFITREFMSKI                       ((0x0026  << 2) + 0xff638400)
  //not used.
#define DMC_DRAM_DFITCTRLUPDI                      ((0x0027  << 2) + 0xff638400)
  //not used.
#define DMC_DRAM_DFITDRAMCLK                       ((0x0028  << 2) + 0xff638400)
//bit 17    dram clk1 enable.
//bit 16    dram clk0 enable.
//bit 15:8  DRAM CLK disable waiting time
//bit 7:0   DRAM CLK enable  enable timer

#define DMC_DRAM_DFITLPRESP                        ((0x002a  << 2) + 0xff638400)
  //bit 3:0.  dfi_lp_ctrl_req response time. after dfi_lp_ctrl_req asserted, and after response time if there's still no dfi_lp_ack respone, then drop the dfi_lp_ctrl_req.

#define DMC_DRAM_TCKECK                            ((0x002c  << 2) + 0xff638400)
 //bit 4:0. tCKECK  from CKE low to assert dfi_dram_clk_disable time. this time + dfi_t_ctrl_delay

#define DMC_DRAM_TREFI                             ((0x002d  << 2) + 0xff638400)
 //write this register will update the auto refresh related register to the auto refresh control logic.
 //bit 31:24:  tZQCI dmc send zqci period.  unit is how much auto refresh period.
 //bit 23:16   pvti  dmc send dfi_ctrlupd_req period.  unit is one auto refresh period.
 //bit 15:8.   tREFI.dmc send auto refresh command period. unit is 100ns.
 //bit 7:0.    t100ns period. unit is dmc clock cycles
#define DMC_DRAM_TSR                               ((0x002e  << 2) + 0xff638400)
  //bit 5:0 tSR.  self resfresh enter to exit time.
#define DMC_DRAM_TCCDMW                            ((0x002f  << 2) + 0xff638400)
  //bit 5:0.  4*tCCD in LPDDR4 mask write.
#define DMC_DRAM_TESCKE                            ((0x0030  << 2) + 0xff638400)
  //bit 5:0  tESCKE.  enter self refresh to power time for LPDDR4.
#define DMC_DRAM_TREFI_DDR3                        ((0x0031  << 2) + 0xff638400)
  //7:0. DDR3 SDRAM tREFI single auto refresh time . the unit is t100ns.
  //use this to check in 8*tREFI time, the DMC should not sent more than 16 auto REFRESH command.
#define DMC_DRAM_TZQCAL                            ((0x0032  << 2) + 0xff638400)
  //11:0. ZQCAL for LPDDR4. ZQINIT/ZQoper for DDR3/4 ZQCL command.
#define DMC_DRAM_T10US                             ((0x0033  << 2) + 0xff638400)
  //10us clock cycle number used for LP2 mode.
#define DMC_DRAM_TMRRI                             ((0x0034  << 2) + 0xff638400)
//bit 7:0   tMRRI for MRR
#define DMC_DRAM_TXS_FAST                          ((0x0035  << 2) + 0xff638400)
 //bit 9:0 DDR4 mode XS_FAST exit self_refrest to zqcl/zqcs/mrs command.
#define DMC_DRAM_DFIODTCFG                         ((0x0036  << 2) + 0xff638400)
  //bit 12.  rank1 ODT default. default vulue for ODT[1] pins if theres no read/write activity.
  //bit 11.  rank1 ODT write sel.  enable ODT[1] if there's write occur in rank1.
  //bit 10.  rank1 ODT write nsel. enable ODT[1] if theres's write occur in rank0.
  //bit 9.   rank1 odt read sel.   enable ODT[1] if there's read occur in rank1.
  //bit 8.   rank1 odt read nsel.  enable ODT[1] if there's read occure in rank0.
  //bit 4.   rank0 ODT default.    default vulue for ODT[0] pins if theres no read/write activity.
  //bit 3.   rank0 ODT write sel.  enable ODT[0] if there's write occur in rank0.
  //bit 2.   rank0 ODT write nsel. enable ODT[0] if theres's write occur in rank1.
  //bit 1.   rank0 odt read sel.   enable ODT[0] if there's read occur in rank0.
  //bit 0.   rank0 odt read nsel.  enable ODT[0] if there's read occure in rank1.
#define DMC_DRAM_DFIODTCFG1                        ((0x0037  << 2) + 0xff638400)
  //bit 27:24  ODT length for BL8 read transfer.
  //bit 19:16. ODT length for BL8 write transfer.
  //bit 12:8.  ODT latency for reads.  suppose to be 0.
  //bit 4:0.   ODT latency for writes.  suppose to be 0.

#define DMC_DRAM_TWODTON                           ((0x0038  << 2) + 0xff638400)
  //bit 5:0   DRAM write access ODT on time.
  //   in DDR3/4 should be same as WL.
  //   in LPDDR4 ODT enable  mode:  tODTLon + tODTon.min
  //   In LPDDR4 ODT disable mode:  tWL.

#define DMC_DRAM_TRETRAIN                          ((0x0039  << 2) + 0xff638400)
 //bit 15:0 LPDDR4 OSCRING retraining timer(units = auto_refresh timer). sync with autorefresh

#define DMC_DRAM_PHYADDRON                         ((0x003a  << 2) + 0xff638400)
  //bit 5:0 PHY_CTRL_ADDR_ON for new PHY. default : 12 unit: DfiClk
#define DMC_DRAM_PHYWRON                           ((0x003b  << 2) + 0xff638400)
  //bit 6:0 PHY_CTRL_ADDR_ON for new PHY. unit: ddr clk
  // PHY_CTRL_WR_ON.  = 20 + WL + (tDQSS+ tDQS2DQ + tWPST)/ddr_clk + BL/2
#define DMC_DRAM_PHYRDON                           ((0x003c  << 2) + 0xff638400)
  // PHY_CTRL_RD_ON.  = 20 + RL + (tDQSCK+ tRPST + tDQSQ)/ddr_clk + BL/2

#define DMC_DRAM_ZQCTRL                            ((0x003d  << 2) + 0xff638400)
  //tZQCI bits in DMC_DRAM_TREFI  defined how many refresh period send ZQCS/ZQUPD/command.
  //this register defines in 0~tZQCI period, which refresh period count to send partical ZQCS/ZACAL/ZQUPD command
  //31:24.  in LPDDR4 case when to send ZQLAT comman to both RANKs of LPDDR4 SDRAM
  //23:16.  when to send PHY ZQ UPDATE command.
  //15:8.   when to send ZQCS/ZQCAL to rank1 DDR SDRAM.
  //7:0.    when to senc ZQCS/ZQCAL to rank0 DDR SDRAM.



//timing paramter for frequency set 1.
#define DMC_NFQ_TMRD                               ((0x0040  << 2) + 0xff638400)
#define DMC_NFQ_TRFC                               ((0x0041  << 2) + 0xff638400)
#define DMC_NFQ_TRP                                ((0x0042  << 2) + 0xff638400)
#define DMC_NFQ_TRTW                               ((0x0043  << 2) + 0xff638400)
#define DMC_NFQ_TCL                                ((0x0044  << 2) + 0xff638400)
#define DMC_NFQ_TCWL                               ((0x0045  << 2) + 0xff638400)
#define DMC_NFQ_TRAS                               ((0x0046  << 2) + 0xff638400)
#define DMC_NFQ_TRC                                ((0x0047  << 2) + 0xff638400)
#define DMC_NFQ_TRCD                               ((0x0048  << 2) + 0xff638400)
#define DMC_NFQ_TRRD                               ((0x0049  << 2) + 0xff638400)
#define DMC_NFQ_TFAW                               ((0x004a  << 2) + 0xff638400)
#define DMC_NFQ_TRTP                               ((0x004b  << 2) + 0xff638400)
#define DMC_NFQ_TWR                                ((0x004c  << 2) + 0xff638400)
#define DMC_NFQ_TWTR                               ((0x004d  << 2) + 0xff638400)
#define DMC_NFQ_TCCD                               ((0x004e  << 2) + 0xff638400)
#define DMC_NFQ_TEXSR                              ((0x004f  << 2) + 0xff638400)
#define DMC_NFQ_TXS                                ((0x0050  << 2) + 0xff638400)
#define DMC_NFQ_TXP                                ((0x0051  << 2) + 0xff638400)
#define DMC_NFQ_TXPDLL                             ((0x0052  << 2) + 0xff638400)
#define DMC_NFQ_TZQCS                              ((0x0053  << 2) + 0xff638400)
#define DMC_NFQ_TCKSRE                             ((0x0054  << 2) + 0xff638400)
#define DMC_NFQ_TCKSRX                             ((0x0055  << 2) + 0xff638400)
#define DMC_NFQ_TCKE                               ((0x0056  << 2) + 0xff638400)
#define DMC_NFQ_TMOD                               ((0x0057  << 2) + 0xff638400)
#define DMC_NFQ_TDQS                               ((0x0058  << 2) + 0xff638400)
#define DMC_NFQ_TRSTL                              ((0x0059  << 2) + 0xff638400)
#define DMC_NFQ_TZQLAT                             ((0x005a  << 2) + 0xff638400)
#define DMC_NFQ_TMRR                               ((0x005b  << 2) + 0xff638400)
#define DMC_NFQ_TCKESR                             ((0x005c  << 2) + 0xff638400)
#define DMC_NFQ_TDPD                               ((0x005d  << 2) + 0xff638400)
#define DMC_NFQ_DFITCTRLDELAY                      ((0x005e  << 2) + 0xff638400)
#define DMC_NFQ_DFITPHYWRDATA                      ((0x005f  << 2) + 0xff638400)
#define DMC_NFQ_DFITPHYWRLAT                       ((0x0060  << 2) + 0xff638400)
#define DMC_NFQ_DFITRDDATAEN                       ((0x0061  << 2) + 0xff638400)
#define DMC_NFQ_DFITPHYRDLAT                       ((0x0062  << 2) + 0xff638400)
#define DMC_NFQ_DFITCTRLUPDMIN                     ((0x0063  << 2) + 0xff638400)
#define DMC_NFQ_DFITCTRLUPDMAX                     ((0x0064  << 2) + 0xff638400)
#define DMC_NFQ_DFITREFMSKI                        ((0x0066  << 2) + 0xff638400)
#define DMC_NFQ_DFITCTRLUPDI                       ((0x0067  << 2) + 0xff638400)
#define DMC_NFQ_DFITDRAMCLK                        ((0x0068  << 2) + 0xff638400)
#define DMC_NFQ_DFITLPRESP                         ((0x006a  << 2) + 0xff638400)
#define DMC_NFQ_TCKECK                             ((0x006c  << 2) + 0xff638400)
#define DMC_NFQ_TREFI                              ((0x006d  << 2) + 0xff638400)
#define DMC_NFQ_TSR                                ((0x006e  << 2) + 0xff638400)
#define DMC_NFQ_TCCDMW                             ((0x006f  << 2) + 0xff638400)
#define DMC_NFQ_TESCKE                             ((0x0070  << 2) + 0xff638400)
#define DMC_NFQ_TREFI_DDR3                         ((0x0071  << 2) + 0xff638400)
#define DMC_NFQ_TZQCAL                             ((0x0072  << 2) + 0xff638400)
#define DMC_NFQ_T10US                              ((0x0073  << 2) + 0xff638400)
#define DMC_NFQ_TMRRI                              ((0x0074  << 2) + 0xff638400)
#define DMC_NFQ_TXS_FAST                           ((0x0075  << 2) + 0xff638400)
#define DMC_NFQ_DFIODTCFG                          ((0x0076  << 2) + 0xff638400)
#define DMC_NFQ_DFIODTCFG1                         ((0x0077  << 2) + 0xff638400)
#define DMC_NFQ_TWODTON                            ((0x0078  << 2) + 0xff638400)
#define DMC_NFQ_TRETRAIN                           ((0x0079  << 2) + 0xff638400)
#define DMC_NFQ_PHYADDRON                          ((0x007a  << 2) + 0xff638400)
#define DMC_NFQ_PHYWRON                            ((0x007b  << 2) + 0xff638400)
#define DMC_NFQ_PHYRDON                            ((0x007c  << 2) + 0xff638400)
#define DMC_NFQ_ZQCTRL                             ((0x007d  << 2) + 0xff638400)
//end of second frequency timing parameter

#define DMC_DRAM_DFITPHYUPDTYPE0                   ((0x0080  << 2) + 0xff638400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 0.
#define DMC_DRAM_DFITPHYUPDTYPE1                   ((0x0081  << 2) + 0xff638400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 1.
#define DMC_DRAM_DFITPHYUPDTYPE2                   ((0x0082  << 2) + 0xff638400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 2.
#define DMC_DRAM_DFITPHYUPDTYPE3                   ((0x0083  << 2) + 0xff638400)
 //dfi_phyupd_ack hold time for dfi_phyupd_req type = 3.

#define DMC_DRAM_MCFG                              ((0x0086  << 2) + 0xff638400)
 //bit 31:27  not used.
 //bit 26:24  rank1_d16_sel.  16bit mode, rank 1 byte selection.
 //bit 23     not used.
 //bit 22:20. rank0_d16_sel. 16bit mode, rank 0 byte selection.
 //bit 19.   send PHY ZQ command  after siu self refresh exit. 1 : enable.  0 : disable.
 //bit 18.   send retrain command after siu self refresh exit. 1 : enable. 0 : disable.
 //bit 17.   in DDR3/4 mode, send ZQCL command after exit register triggered self refresh.
 //bit 16.   send refresh command after finish frequency change. 1 : enable. 0 : disable.
 //bit 15.   send refresh command after finish LPDDR4 retraining. 1 : enable. 0 : disable.
 //bit 14.   1: cke init low.  0 : cke init high.
 //bit 13    1: dbi write enable only for LPDDR4.
 //bit 12.   1: dbi read inversion.   0:  dbi read high inversion.
 //bit 11.   1: dbi read enable. 0:  dbi not enabled.
 //bit 10    1: enable staggered chip select for 2 ranks DRAM.
 //bit 9     1: enable send auto refresh command to DDR SDRAM when PCTL is in CFG/STOP state.
 //bit 8     send auto refr cmd before enter register triggered  self refresh
 //bit 7     send auto refr cmd after exit regsiter triggered self refresh mode.
 //bit 6     disable dram clock after enter register triggered self refresh.
 //bit 5     send DFI_LP_REQ to PHY after enter register triggered elf refresh mode.
 //bit 4     send DRAM to power down mode after enter self refresh. ONLY for LPDDR4.
 //bit 3     send DFI_CTRLUPD_REQ after exit register triggered self refresh.
 //bit 2     send ZQCS command after exit register triggered self refresh.
 //bit 1     enable PHY triggered DFI_PHYUPD_REQ.
 //bit 0     2T mode. always 1 in DDR3/4 mode.

#define DMC_DRAM_ZQ_CTRL                           ((0x0087  << 2) + 0xff638400)
 //bit 2  ZQ command must be send in different time.
 //bit 1  ZQ command can be send at same time.
 //bit 0  rank0 ZQ only


#define DMC_DRAM_DFI_CTRL                          ((0x0089  << 2) + 0xff638400)
  //bit 31 siu_dfi_lat err generation enable.  1: if dfi read latency violation, generate data error. 0 : disable.
  //bit 19: dfi_init_complete wait enable.  1: after dfi_init_complete, wait additional EXSR time for new command. 0: phy will handle all the timing    after dfi_init_complete DMC can do everything they want.
  //bit 18:  dfi_rddata_cs_n polariy.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.
  //bit 17:  dfi_wrdata_cs_n polariy.  0:  rank0 select = 2'b10. rank1 select = 2'b10. 1: rank0 select = 2'b01, rank1_select = 2'b10.
  //bit 16:  force PHY ctrl_on  if = 1, phy_ctrl_on singal will keep on.
   //bit 15 siu_dfi1_lp_en
  //bit 14 siu_dfi_lp_ack_and
  //bit 13 siu_dfi_lp_ack_or
  //bit 12 siu_dfi1_init_start_en
  //bit 11 siu_dfi_init_com_and
  //bit 10 siu_dfi_init_com_or
  //bit  9 siu_dfi1_freq_en
  //bit  8 siu_dfi1_dram_clk_dis_en
  //bit  7 siu_dfi_phyupd_type_sel
  //bit  6 siu_dfi1_phyupd_ack_en
  //bit  5 siu_dfi_phyupd_req_and
  //bit  4 siu_dfi_phyupd_req_or
  //bit  3 siu_dfi_ctrlupd_ack_and
  //bit  2 siu_dfi_ctrlupd_ack_or
  //bit  1 siu_dfi1_ctrlupd_req_en
  //bit  0 siu_dfi1_cmd_en

#define DMC_DRAM_DFIINITCFG                        ((0x008a  << 2) + 0xff638400)
  //bit 31.   dfi_init_complete status. read only.
  //bit 15:14.  Frequency set 1 dfi_freq_ratio value.
  //bit 12:8    Frequency set 1 dfi_freq value.
  //bit 7:6     Frequency set 0 dfi_freq_ratio value.
  //bit 5:1     Frequency set 0 dfi_freq value.
  //bit 0.      dfi_init_start value  can be use manually config dfi_init_start signal.

#define DMC_DRAM_APD_CTRL                          ((0x008c  << 2) + 0xff638400)
 //bit 19:16  DFI_LP_WAKEUP value in APD DFI_LP_REQ mode
 //bit 12    1: exit power down slow mode(waiting PLL LOCK).  0 : fast mode.
 //bit 11    enable DFI_LP_REQ when enter Auto power down mode.
 //bit 10    disable DFI_clk_disable when enter auto power down mode.
 //bit 9:0    0  disable auto power down mode.
            //non zero value to enable auto power down when DMC is in idle state for this number of clock cycles.

#define DMC_DRAM_ASR_CTRL                          ((0x008d  << 2) + 0xff638400)
  //bit 31. enable RETRAIN PHY after auto selfrefresh exit. for AM_PHY only.
  //bit 30. in DDR3/4 mode, send ZQCL command after exit from auto self refresh mode.
  //bit 29. enable PHY clock in LP2 mode.  1: enable. 0 : disable.
  //bit 28. enable dmc wait 10us after LP2 mode exit if it's long time the PHY in LP2 mode..
  //bit [27:24] DFI_LP_WAKEUP value in self refresh DFI_LP_REQ mode.
  //bit 23 : send REFRESH command after exit from auto self refersh mode(ASR).
  //bit 22 : send REFERSH command before enter to Auto self refresh mode(ASR).
  //bit 21 : send ZQCS command after exit from Auto self refresh mode(ASR).
  //bit 20 : send dfi_ctrl_upd after exit from ASR mode
  //bit 19 : send power down command when enter ASR mode. //for LPDDR4 only.
  //bit 18 : set the PHY enter LP2 mode after enter ASR mode.
  //bit 17 : send DFI_LP_REQ  after enter ASR mode.
  //bit 16 : set DFI_CLK_DISABLE after enter ASR mode.
  //bit 15:0.   0 disable auto ASR mode.
             // Non-zero valule enable ASR mode. when DMC is in idle state for this number of clock cycles, the DMC will enter ASR mode.

#define DMC_DRAM_REFR_CTRL                         ((0x0092  << 2) + 0xff638400)
  //bit 22  dmc to control DFI_CTRLUPD_REQ  with zq generation together.
  //bit 21  dmc to control PHY ZQ generation enable.
  //bit 20  dmc to control zqlat(in LPDDR4 mode) generation enable.
  //bit 19  dmc to control zqcs1 generation enable.
  //bit 18  dmc to control zqcs0 generation enable.
  //bit 17:8 auto refresh request pending cnt if there's page hit request.
  //bit 7  retrain enable for auto refresh requent. 1: enable. 0: disable.
  //bit 6  Disabled auto refresh command if over 16 auto refresh command sent in 2 TREFI_DDR3 period
  //bit 5  enable dmc send ZQCS command .
  //bit 4. enable dmc send DFI_CTRUPD_REQ.
  //bit 3:1. how many refresh command send for one period. = this number + 1
  //bit 0.  enable dmc send auto refresh command.


#define DMC_DRAM_FREQ_CTRL                         ((0x0093  << 2) + 0xff638400)
//bit 31 .  write 1 to change freqency   read 0: finished.
//bit 30.   waiting for software to send some manual command.  1 : waiting. 0 : not ready yet.
//bit 29:22.  not used.
//bit 21     after Freqchange send PHY ZQ update.
//bit 20    send CTRLUPD_REQ to PHY after freq_change finished.
//bit 19:16. how many cycles to send PLL change req after init_complete signal to low.
//bit 15.   freq pre  config_en. Before freq enter stop state let DMC configure DDR SDRAM.
//bit 14.   freq post config_en. After  freq enter stop state let DMC configure DDR SDRAM.
//bit 13.   send zqcl after freq change in DDR3/4 mode.
//bit 12.   send zqcs after freq change. 1: enable. 0 not send.
//bit 11.   in AUTO MRW fucntion: the data format.  1: use USR_CMD format.  0: MRW format.
//bit 10.   AUTO MRW function:  1 use hardware auto MRW function.  0: don't do auto MRW.
//bit 9.  1 : FREQ MRW done. let FREQ change machine continue.
//bit 8   FREQ WAIT. 1 when freq change finishes, state machine stop at self refresh state in case there's something need to handle.
              //     0 after freq change finishes  the state machine go back to access state.
//bit 7   when change PLL setting, disable dmc clock
//bit 6   when change PLL setting, disable PHY DfiClk and DfiCtlClk.
//bit 5   check vpu_sleep_en ==1 when do FREQ change.  if vpu_sleep_en == 0, just wait.
//bit 4   nxt frequency selection.  1 = freq1. 0 = freq0.
//bit 3:1.  not used.
//bit 0.   current frequency selection.

#define DMC_DRAM_SCFG                              ((0x0094  << 2) + 0xff638400)
  // bit 2:0 only one bit can be high at same time.
  // bit 2  1 : to ask PCTL enter ACCESS STATE.  0 : deassert the request.
  // bit 1  1 : to ask PCTL enter SELF REFRESH STATE.  0 : deassert the request.
  // bit 0  1 : to ask PCTL enter STOP/CONFIG STATE .  0 : deassert the request.

#define DMC_DRAM_STAT                              ((0x0095  << 2) + 0xff638400)
  //bit 31     rd latency error. 1: means after dfiphytrdlat cycles, the read data still not back.
  //bit 28:24   dram_sr_state
  //bit 23:20   stop_st
  //bit 19:15   sleep_st
  //bit 14:12  ACCESS STATUS 0 :  ACCESS is in normal working mode.
                          //1 :   ACCESS sending precharege command.
                          //2 :   ACCESS sending AUTO REFESH command.
                          //3 :   ACCESS sending DIF_CTRLUPD_REQ command.
                          //4 :   ACCESS sending ZQCS command to DDR DRAM(ZQCAL for LPDDR4).
                          //5 :   ACCESS sending ZQLATCH command to  LPDDR4 only.

  //bit 11:8   APD STATUS:   0 :   APD_IDLE
                          //1 :    APD sending PRECHARGE command
                          //2 :    APD sending CKE low command
                          //3 :    APD sending DISABLE DRAM CLOCK command
                          //4 :    APD sending DFI_LP_CTRL_REQ
                          //5 :    APD in Auto Power down mode.
                          //6 :    APD deassert DFI_LP_CTRL_REQ
                          //7 :    APD sending enable DRAM CLOCK command
                          //8 :    APD sending out CKE high command.
  //bit 7:4: DRAM_STATUS:  0  :    DRAM IDLE
                         //1  :    DRAM_STOP/DRAM_CFG
                         //2  :    DRAM_ACCESS
                         //3  :    DRAM_SLEEP
                         //4  :    DRAM APD(AUTO POWER DOWN).
                         //5  :    IDLE -> STOP/CONFIG
                         //6  :    STOP -> SLEEP
                         //7  :    STOP -> ACCESS
                         //8  :    ACCESS -> SLEEP.
                         //9  :    ACCESS -> STOP
                         //A  :    ACCESS -> APD
                         //B  :    SLEEP -> STOP
                         //C  :    SLEEP -> ACCESS
                         //D  :    APD -> ACCESS
   //bit 3        reserved.
   //bit 2        1 : DRAM enter normal working state.
   //bit 1        1 : DRAM enter sleep state. self refresh state.
   //bit 0        1 : dram enter cfg state.

#define DMC_DRAM_STAT1                             ((0x0096  << 2) + 0xff638400)
  //bit 11:8  freq_st.
    //4'h0 : IDLE
    //4'h1 : FREQ_CHECK_VPU
    //4'h2 : FREQ_WAITING_STOP
    //4'h3 : FREQ_DRAM_CFG.  waiting DMC/software to send special MRW/MPC command to configure DDR SDRAM either before Freq change or after freq change.
    //4'h4 : FREQ_SELF_REFR_ST.
    //4'h5 : FREQ_SET_DFI_FREQ.
    //4'h6 : FREQ_DFI_INIT_START_HIGH.
    //4'h7 : FREQ_CHANGE PLL_ST.
    //4'h8 : FREQ_UPDATA REG.
    //4'h9 : FREQ_DFI_INIT_START_LOW.
    //4'ha : FREQ_WAITING_FINISH
    //4'hb : FREQ_ZQCS
    //4'hc : FREQ_ZQ_LATCH
    //4'hd : FREQ_PVT
  //bit 7:5   train_st
  //bit 4:0   dram_phy_st


#define DMC_PHY_RETRAINING_CTRL                    ((0x0097  << 2) + 0xff638400)
  //bit 31 :  phy_retraining enable.
  //bit 30 :  check  vpu sleep_en.
  //bit 25:24 : retraining dfi_freq[4:3], the [2:0] bit still use the dfi_freq bits to keep the frequency.
  //bit 23:0: retraining period unit : 100ns.


#define DMC_DFI_ERR_STAT                           ((0x0098  << 2) + 0xff638400)
 //LPDDR4 PHY DFI error infomation.
 //bit 31:20. not used.
 //bit 9.    ddr0_dfi_error
 //bit 8:5   ddr0_dfi_error_info.
 //bit 4.    ddr1_dfi_error.
 //bit 3:0.  ddr1_dfi_error_info.


#define DMC_LP2_TIMER                              ((0x009a  << 2) + 0xff638400)
//bit 15:0.   timer setting to measure how long the chip is entered LP2 mode.
//this timer is 40bits counter with DMC PCLK.
//we use the high 16bits to compare this register. if the counter is large than this number,  that means  the PHY need addition 10us after wakeup the PHY and before exit self_refresh mode.


#define DMC_DRAM_COMPLETE_WAIT                     ((0x009b  << 2) + 0xff638400)
 //read only how long to waiting for DFI_INIT_COMPLETE become high after DFI_INIT_START triggered.

#define DMC_DRAM_DFI_SWAP_0                        ((0x00a0  << 2) + 0xff638400)
  //bit 5:0. dfi_act_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].

#define DMC_DRAM_DFI_SWAP_1                        ((0x00a1  << 2) + 0xff638400)
  //bit 5:0. dfi_ras_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_2                        ((0x00a2  << 2) + 0xff638400)
  //bit 5:0. dfi_cas_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_3                        ((0x00a3  << 2) + 0xff638400)
  //bit 5:0. dfi_we_n function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_4                        ((0x00a4  << 2) + 0xff638400)
  //bit 5:0. dfi_bg0 function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_5                        ((0x00a5  << 2) + 0xff638400)
  //bit 5:0. dfi_bg[1] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_6                        ((0x00a6  << 2) + 0xff638400)
  //bit 5:0. dfi_ba[0] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_7                        ((0x00a7  << 2) + 0xff638400)
  //bit 5:0. dfi_ba[1] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_8                        ((0x00a8  << 2) + 0xff638400)
  //bit 5:0. dfi_ba[2] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_9                        ((0x00a9  << 2) + 0xff638400)
  //bit 5:0. dfi_a[0] function select
  // 6'h00 : the function itself.
  // 6'h01 : act_n.
  // 6'h02 : ras_n.
  // 6'h03 : cas_n.
  // 6'h04 : we_n.
  // 6'h05 : bg[0].
  // 6'h06 : bg[1].
  // 6'h07 : ba[0].
  // 6'h08 : ba[1].
  // 6'h09 : ba[2].
  // 6'h0a : a[0].
  // 6'h0b : a[1].
  // 6'h0c : a[2].
  // 6'h0d : a[3].
  // 6'h0e : a[4].
  // 6'h0f : a[5].
  // 6'h10 : a[6].
  // 6'h11 : a[7].
  // 6'h12 : a[8].
  // 6'h13 : a[9].
  // 6'h14 : a[10].
  // 6'h15 : a[11].
  // 6'h16 : a[12].
  // 6'h17 : a[13].
  // 6'h18 : a[14].
  // 6'h19 : a[15].
  // 6'h1a : a[16].
  // 6'h1b : a[17].
#define DMC_DRAM_DFI_SWAP_10                       ((0x00aa  << 2) + 0xff638400)
  //bit 5:0. dfi_a[1] function select
#define DMC_DRAM_DFI_SWAP_11                       ((0x00ab  << 2) + 0xff638400)
  //bit 5:0. dfi_a[2] function select
#define DMC_DRAM_DFI_SWAP_12                       ((0x00ac  << 2) + 0xff638400)
  //bit 5:0. dfi_a[3] function select
#define DMC_DRAM_DFI_SWAP_13                       ((0x00ad  << 2) + 0xff638400)
  //bit 5:0. dfi_a[4] function select
#define DMC_DRAM_DFI_SWAP_14                       ((0x00ae  << 2) + 0xff638400)
  //bit 5:0. dfi_a[5] function select
#define DMC_DRAM_DFI_SWAP_15                       ((0x00af  << 2) + 0xff638400)
  //bit 5:0. dfi_a[6] function select
#define DMC_DRAM_DFI_SWAP_16                       ((0x00b0  << 2) + 0xff638400)
  //bit 5:0. dfi_a[7] function select
#define DMC_DRAM_DFI_SWAP_17                       ((0x00b1  << 2) + 0xff638400)
  //bit 5:0. dfi_a[8] function select
#define DMC_DRAM_DFI_SWAP_18                       ((0x00b2  << 2) + 0xff638400)
  //bit 5:0. dfi_a[9] function select
#define DMC_DRAM_DFI_SWAP_19                       ((0x00b3  << 2) + 0xff638400)
  //bit 5:0. dfi_a[10] function select
#define DMC_DRAM_DFI_SWAP_20                       ((0x00b4  << 2) + 0xff638400)
  //bit 5:0. dfi_a[11] function select
#define DMC_DRAM_DFI_SWAP_21                       ((0x00b5  << 2) + 0xff638400)
  //bit 5:0. dfi_a[12] function select
#define DMC_DRAM_DFI_SWAP_22                       ((0x00b6  << 2) + 0xff638400)
  //bit 5:0. dfi_a[13] function select
#define DMC_DRAM_DFI_SWAP_23                       ((0x00b7  << 2) + 0xff638400)
  //bit 5:0. dfi_a[14] function select
#define DMC_DRAM_DFI_SWAP_24                       ((0x00b8  << 2) + 0xff638400)
  //bit 5:0. dfi_a[15] function select
#define DMC_DRAM_DFI_SWAP_25                       ((0x00b9  << 2) + 0xff638400)
  //bit 5:0. dfi_a[16] function select
#define DMC_DRAM_DFI_SWAP_26                       ((0x00ba  << 2) + 0xff638400)
  //bit 5:0. dfi_a[17] function select

#define DMC_DRAM_CMD                               ((0x00d0  << 2) + 0xff638400)
 //bit 31. cmd done.  write 0 to clean.
 //bit 30. data done. write 0 to clean.
 //bit 5.  user defined command.
 //bit 4.  LPDDR4 MPC write data command( MPC WR FIFO).
 //bit 3.  LPDDR4 MPC read data command (MPC RD Calibration and RD FIFO).
 //bit 2.  LPDDR4 MPC-1 command ( NOP,  Start DQS interval ....)
 //bit 1.  mrr comand.
 //bit 0.  mrw command.

#define DMC_DRAM_CMD_CODE                          ((0x00d1  << 2) + 0xff638400)
 //bit 31:28  user command case: = {act_n, ras_n, cas_n, we_n}
 //bit 27:26. 128bits data cycles . 0: 1 clock cycles;  1: 2  clock cycles; 2: 3 clock cycles; 3:4 clock cycles.
 //           LPDDR4 : 4 clock cycles;
 //           DDR3/4/LPDDR3  : 2 clock cycles.
 //bit 25     MRW/MRR/MPC command rank 1 select.  1: select.  0: not select.
 //bit 24.    MRW/MRR/MPC command rank 0 select.  1: select.  0: not select.
 //bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0].    20:19 BG[1:0].
 //bit 15:0   opcode.

#define DMC_DRAM_CMD_TIME                          ((0x00d2  << 2) + 0xff638400)
//bit 31:16  PRE  CMD timer. //delay how many cycle to start the command.
//bit 15:0   POST CMD timer  //delay how many cycle after the command execute.

#define DMC_DRAM_WSTRB0                            ((0x00d3  << 2) + 0xff638400)
#define DMC_DRAM_WSTRB1                            ((0x00d4  << 2) + 0xff638400)
#define DMC_DRAM_RDBI0                             ((0x00d5  << 2) + 0xff638400)
  //MPC RD FIFO command DBI read back data
  //bit 31:16  the second cycle.
  //bit 15:0   the first cycle.
#define DMC_DRAM_RDBI1                             ((0x00d6  << 2) + 0xff638400)
  //MPC RD FIFO command DBI read back data
  //bit 31:16. the Forth cycle.
  //bit 15:0.  the third cycle.

//WD0~16 and RD0~16 can be used as MRW command as Frequency change .
//WD0~16 is for Freq1 DRAM MR setting, it would send to DRAM right before FREQ0-> FREQ1
//RD0_16 is for Freq0 DRAM MR setting. it would send to DRAM right before FREQ1-> FREQ0.
//each register can be one MRW command. So total 16 MRW command can be sent to DRAM.
//The register formats:
//bit 31.   MRW/USER comand enable.  1: enabled command. 0 not enabled.
//bit 30.   last MRW/USER command.   if this bit =1, After send this command, the DRAM controller will contine frequency next stage.
//bit 29:26. USER COMMAND parameter: in DDR3/DDR4.  {act_n, ras_n, cas_n, we_n} value for user command
                                     //in LPDDR4.  bit 16: 1 4 cycles command.  0 2 cycles command.
//bit 25     MRW/USER command rank 1 select.  1: select.  0: not select.
//bit 24.    MRW/USER command rank 0 select.  1: select.  0: not select.
//bit 23:0.  USER command.
             //DDR3:    18:16 bank address. 15:0:  address.
             //DDR4:    20:19 bank group address.   18:16: bank address. 15:0 address.
             //LPDDR3:   9:0. rising edge address.  19:10.  falling edge address.
             //LPDDR4.   5:0, first edge address,  11:6 second edge address, 17:12: third edge address. 23:18, forth edge address.
           //MRW command format:
              //bit 23:16  MR addr.  DDR4 case :  18:16 ba[2:0].    20:19 BG[1:0].
              //bit 15:0   opcode.
#define DMC_DRAM_WD0                               ((0x00e0  << 2) + 0xff638400)
#define DMC_DRAM_WD1                               ((0x00e1  << 2) + 0xff638400)
#define DMC_DRAM_WD2                               ((0x00e2  << 2) + 0xff638400)
#define DMC_DRAM_WD3                               ((0x00e3  << 2) + 0xff638400)
#define DMC_DRAM_WD4                               ((0x00e4  << 2) + 0xff638400)
#define DMC_DRAM_WD5                               ((0x00e5  << 2) + 0xff638400)
#define DMC_DRAM_WD6                               ((0x00e6  << 2) + 0xff638400)
#define DMC_DRAM_WD7                               ((0x00e7  << 2) + 0xff638400)
#define DMC_DRAM_WD8                               ((0x00e8  << 2) + 0xff638400)
#define DMC_DRAM_WD9                               ((0x00e9  << 2) + 0xff638400)
#define DMC_DRAM_WD10                              ((0x00ea  << 2) + 0xff638400)
#define DMC_DRAM_WD11                              ((0x00eb  << 2) + 0xff638400)
#define DMC_DRAM_WD12                              ((0x00ec  << 2) + 0xff638400)
#define DMC_DRAM_WD13                              ((0x00ed  << 2) + 0xff638400)
#define DMC_DRAM_WD14                              ((0x00ee  << 2) + 0xff638400)
#define DMC_DRAM_WD15                              ((0x00ef  << 2) + 0xff638400)

#define DMC_DRAM_RD0                               ((0x00f0  << 2) + 0xff638400)
#define DMC_DRAM_RD1                               ((0x00f1  << 2) + 0xff638400)
#define DMC_DRAM_RD2                               ((0x00f2  << 2) + 0xff638400)
#define DMC_DRAM_RD3                               ((0x00f3  << 2) + 0xff638400)
#define DMC_DRAM_RD4                               ((0x00f4  << 2) + 0xff638400)
#define DMC_DRAM_RD5                               ((0x00f5  << 2) + 0xff638400)
#define DMC_DRAM_RD6                               ((0x00f6  << 2) + 0xff638400)
#define DMC_DRAM_RD7                               ((0x00f7  << 2) + 0xff638400)
#define DMC_DRAM_RD8                               ((0x00f8  << 2) + 0xff638400)
#define DMC_DRAM_RD9                               ((0x00f9  << 2) + 0xff638400)
#define DMC_DRAM_RD10                              ((0x00fa  << 2) + 0xff638400)
#define DMC_DRAM_RD11                              ((0x00fb  << 2) + 0xff638400)
#define DMC_DRAM_RD12                              ((0x00fc  << 2) + 0xff638400)
#define DMC_DRAM_RD13                              ((0x00fd  << 2) + 0xff638400)
#define DMC_DRAM_RD14                              ((0x00fe  << 2) + 0xff638400)
#define DMC_DRAM_RD15                              ((0x00ff  << 2) + 0xff638400)



//
// Closing file:  ../mmc_lp4/dmc/rtl/dmc_siu_reg.vh
//
//
// Reading file:  ../mmc_lp4/dmc/rtl/dmc_sticky_reg.vh
//
// -----------------------------------------------
// REG_BASE:  DMC_STICKY_REG_BASE = 0xff638800
// -----------------------------------------------
//those register is for software save some tempary value. and because it's in RAM. it won't lose if DMC get reseted.
#define DMC_STICKY_0                               ((0x0000  << 2) + 0xff638800)
#define DMC_STICKY_1                               ((0x0001  << 2) + 0xff638800)
#define DMC_STICKY_2                               ((0x0002  << 2) + 0xff638800)
#define DMC_STICKY_3                               ((0x0003  << 2) + 0xff638800)
#define DMC_STICKY_4                               ((0x0004  << 2) + 0xff638800)
#define DMC_STICKY_5                               ((0x0005  << 2) + 0xff638800)
#define DMC_STICKY_6                               ((0x0006  << 2) + 0xff638800)
#define DMC_STICKY_7                               ((0x0007  << 2) + 0xff638800)
#define DMC_STICKY_8                               ((0x0008  << 2) + 0xff638800)
#define DMC_STICKY_9                               ((0x0009  << 2) + 0xff638800)
#define DMC_STICKY_10                              ((0x000a  << 2) + 0xff638800)
#define DMC_STICKY_11                              ((0x000b  << 2) + 0xff638800)
#define DMC_STICKY_12                              ((0x000c  << 2) + 0xff638800)
#define DMC_STICKY_13                              ((0x000d  << 2) + 0xff638800)
#define DMC_STICKY_14                              ((0x000e  << 2) + 0xff638800)
#define DMC_STICKY_15                              ((0x000f  << 2) + 0xff638800)
#define DMC_STICKY_16                              ((0x0010  << 2) + 0xff638800)
#define DMC_STICKY_17                              ((0x0011  << 2) + 0xff638800)
#define DMC_STICKY_18                              ((0x0012  << 2) + 0xff638800)
#define DMC_STICKY_19                              ((0x0013  << 2) + 0xff638800)
#define DMC_STICKY_20                              ((0x0014  << 2) + 0xff638800)
#define DMC_STICKY_21                              ((0x0015  << 2) + 0xff638800)
#define DMC_STICKY_22                              ((0x0016  << 2) + 0xff638800)
#define DMC_STICKY_23                              ((0x0017  << 2) + 0xff638800)
#define DMC_STICKY_24                              ((0x0018  << 2) + 0xff638800)
#define DMC_STICKY_25                              ((0x0019  << 2) + 0xff638800)
#define DMC_STICKY_26                              ((0x001a  << 2) + 0xff638800)
#define DMC_STICKY_27                              ((0x001b  << 2) + 0xff638800)
#define DMC_STICKY_28                              ((0x001c  << 2) + 0xff638800)
#define DMC_STICKY_29                              ((0x001d  << 2) + 0xff638800)
#define DMC_STICKY_30                              ((0x001e  << 2) + 0xff638800)
#define DMC_STICKY_31                              ((0x001f  << 2) + 0xff638800)
#define DMC_STICKY_32                              ((0x0020  << 2) + 0xff638800)
#define DMC_STICKY_33                              ((0x0021  << 2) + 0xff638800)
#define DMC_STICKY_34                              ((0x0022  << 2) + 0xff638800)
#define DMC_STICKY_35                              ((0x0023  << 2) + 0xff638800)
#define DMC_STICKY_36                              ((0x0024  << 2) + 0xff638800)
#define DMC_STICKY_37                              ((0x0025  << 2) + 0xff638800)
#define DMC_STICKY_38                              ((0x0026  << 2) + 0xff638800)
#define DMC_STICKY_39                              ((0x0027  << 2) + 0xff638800)
#define DMC_STICKY_40                              ((0x0028  << 2) + 0xff638800)
#define DMC_STICKY_41                              ((0x0029  << 2) + 0xff638800)
#define DMC_STICKY_42                              ((0x002a  << 2) + 0xff638800)
#define DMC_STICKY_43                              ((0x002b  << 2) + 0xff638800)
#define DMC_STICKY_44                              ((0x002c  << 2) + 0xff638800)
#define DMC_STICKY_45                              ((0x002d  << 2) + 0xff638800)
#define DMC_STICKY_46                              ((0x002e  << 2) + 0xff638800)
#define DMC_STICKY_47                              ((0x002f  << 2) + 0xff638800)
#define DMC_STICKY_48                              ((0x0030  << 2) + 0xff638800)
#define DMC_STICKY_49                              ((0x0031  << 2) + 0xff638800)
#define DMC_STICKY_50                              ((0x0032  << 2) + 0xff638800)
#define DMC_STICKY_51                              ((0x0033  << 2) + 0xff638800)
#define DMC_STICKY_52                              ((0x0034  << 2) + 0xff638800)
#define DMC_STICKY_53                              ((0x0035  << 2) + 0xff638800)
#define DMC_STICKY_54                              ((0x0036  << 2) + 0xff638800)
#define DMC_STICKY_55                              ((0x0037  << 2) + 0xff638800)
#define DMC_STICKY_56                              ((0x0038  << 2) + 0xff638800)
#define DMC_STICKY_57                              ((0x0039  << 2) + 0xff638800)
#define DMC_STICKY_58                              ((0x003a  << 2) + 0xff638800)
#define DMC_STICKY_59                              ((0x003b  << 2) + 0xff638800)
#define DMC_STICKY_60                              ((0x003c  << 2) + 0xff638800)
#define DMC_STICKY_61                              ((0x003d  << 2) + 0xff638800)
#define DMC_STICKY_62                              ((0x003e  << 2) + 0xff638800)
#define DMC_STICKY_63                              ((0x003f  << 2) + 0xff638800)
//
// Closing file:  ../mmc_lp4/dmc/rtl/dmc_sticky_reg.vh
//
//
// Closing file:  ./mmc_reg.vh
//

#endif // MMC_REG_DEFINE

